\subsection{Cryptosystems}
We want to modify a message such that it becomes unintelligible to an eavesdropper Eve.
Certain secret information is shared between two participants Alice and Bob, called the \emph{key}, chosen from a set of possible keys \( \mathcal K \).
The unencrypted message is called the \emph{plaintext}, which lies in a set \( \mathcal M \), and the encrypted message is called the \emph{ciphertext}, and lies in a set \( \mathcal C \).
A \emph{cryptosystem} consists of \( (\mathcal K, \mathcal M, \mathcal C) \) together with the \emph{encryption} function \( e \colon \mathcal M \times \mathcal K \to \mathcal C \) and \emph{decryption} function \( d \colon \mathcal C \times \mathcal K \to \mathcal M \).
These maps have the property that \( d(e(m, k), k) = m \) for all \( m \in \mathcal M, k \in \mathcal K \).
\begin{example}
    Suppose \( \mathcal M = \mathcal C = \qty{A, B, \dots, Z}^\star = \Sigma^\star \).
    The \emph{simple substitution cipher} defines \( \mathcal K \) to be the set of permutations of \( \Sigma \).
    To encrypt a message, each letter of plaintext is replaced with its image under a chosen permutation \( \pi \in \mathcal K \).

    The \emph{Vigen\`ere} cipher has \( \mathcal K = \Sigma^d \) for some \( d \).
    We identify \( \Sigma \) and \( \faktor{\mathbb Z}{26\mathbb Z} \).
    Write out the key repeatedly below the plaintext, and add each plaintext letter with the corresponding key letter to produce a letter of ciphertext.
    For instance, encrypting the plaintext ATTACKATDAWN with the key LEMON gives ciphertext LXFOPVEFRNHR.
    Note, for instance, that each occurrence of the letter A in the plaintext corresponds to a letter of the key in the ciphertext.
    If \( d = 1 \), this is the \emph{Caesar cipher}.
\end{example}

\subsection{Breaking cryptosystems}
Eve may know \( e \) and \( d \), as well as the probability distributions of \( \mathcal K, \mathcal M \), but she does not know the key itself.
She seeks to recover the plaintext from a given string of ciphertext.
There are three possible attack levels.
\begin{enumerate}[1.]
    \item (ciphertext-only) Eve only knows some piece of ciphertext.
    \item (known-plaintext) Eve knows a considerable length of plaintext and its corresponding ciphertext, but not the key.
    In other words, she knows \( m \) and \( e(m,k) \), but not \( k \).
    \item (chosen plaintext) Eve can acquire the ciphertext for any plaintext message; she can generate \( e(m,k) \) for any \( m \).
\end{enumerate}
\begin{remark}
    The simple substitution cipher and Vigen\`ere cipher fail at Level 1 in English if the messages are sufficiently long, as we can perform frequency analysis.
    Even if the plaintext is suitably random, both examples can fail at Level 2.
    For modern applications, Level 3 security is desirable.
\end{remark}
% TODO: too little indent in enumerate above
Consider a cryptosystem \( (\mathcal M, \mathcal K, \mathcal C) \).
We model the keys and messages as independent random variables \( K, M \) taking values in \( \mathcal K, \mathcal M \).
The ciphertext random variable is \( C = e(K,M) \in \mathcal C \).
\begin{definition}
    A cryptosystem \( (\mathcal M, \mathcal K, \mathcal C) \) has \emph{perfect secrecy} if \( H(M \mid C) = H(M) \), or equivalently, \( M \) and \( C \) are independent, or \( I(M;C) = 0 \).
\end{definition}
One can show that perfect secrecy implies that \( \abs{\mathcal K} \geq \abs{\mathcal M} \).
\begin{definition}
    The \emph{message equivocation} is \( H(M \mid C) \).
    The \emph{key equivocation} is \( H(K \mid C) \).
\end{definition}
\begin{lemma}
    \( H(M \mid C) \leq H(K \mid C) \).
\end{lemma}
\begin{proof}
    Note that \( M = d(C,K) \), hence \( H(M \mid C, K) = 0 \).
    Therefore, \( H(C,K) = H(M,C,K) \).
    So
    \[ H(K \mid C) = H(K,C) - H(C) = H(M,C,K) - H(M \mid K,C) - H(C) = H(M,K,C) - H(C) = H(K \mid M,C) + H(M,C) - H(C) = H(K \mid M, C) + H(M \mid C) \]
    Hence \( H(K \mid C) \geq H(M \mid C) \).
\end{proof}
Let \( \mathcal M = \mathcal C = \mathcal A \), and suppose we send \( n \) messages modelled as \( M^{(n)} = (M_1, \dots, M_n) \) encrypted as \( C^{(n)} = (C_1, \dots, C_n) \) using the same key \( K \).
\begin{definition}
    The \emph{unicity distance} is the least \( n \) such that \( H(K \mid C^{(n)}) = 0 \); it is the smallest number of encrypted messages required to uniquely determine the key.
\end{definition}
Now,
\[ H(K \mid C^{(n)}) = H(K, C^{(n)}) - H(C^{(n)}) = H(K, M^{(n)}, C^{(n)}) - H(C^{(n)}) = H(K, M^{(n)}) - H(C^{(n)}) = H(K) + H(M^{(n)}) - H(C^{(n)}) \]
as \( K, M^{(n)} \) are independent.
We make the following assumptions.
\begin{enumerate}
    \item All keys are equally likely, so \( H(K) = \log \abs{\mathcal K} \).
    \item \( H(M^{(n)}) \approx nH \) for some constant \( H \) and sufficiently large \( n \).
    \item All sequences of ciphertext are equally likely, so \( H(C^{(n)}) = n \log \abs{\mathcal A} \).
\end{enumerate}
Hence,
\[ H(K \mid C^{(n)}) = \log \abs{\mathcal K} + nH - n \log \abs{\mathcal A} \geq 0 \]
This holds if and only if
\[ n \leq U = \frac{\log \abs{\mathcal K}}{\log \abs{\mathcal A} - H} \]
Equivalently, \( \frac{\log \abs{\mathcal A}}{R\log \abs{\mathcal A}} \) where \( R = 1 - \frac{H}{\log \abs{\mathcal A}} \) is the \emph{redundancy} of the source.
Recall that \( 0 \leq H \leq \log \abs{\mathcal A} \).
To make the unicity distance large, we can make the number of keys large, or use a message source with little redundancy.

\subsection{One-time pad}
Consider streams in \( \mathbb F_2 \) representing the plaintext \( p_0, p_1, \dots \), the key stream \( k_0, k_1, \dots \), and the ciphertext \( z_0, z_1, \dots \) where \( z_n = p_n + k_n \).
\begin{definition}
    A \emph{one-time pad} is a cryptosystem where \( k \) is generated randomly; the \( k_i \) are independent and take values of 0 or 1 with probability \( \frac{1}{2} \).
\end{definition}
\( z = p + k \) is now a stream of independent and identically distributed random variables taking values of 0 or 1 with probability \( \frac{1}{2} \).
Hence, without the key stream, deciphering is impossible, so the unicity distance is infinite.
One can show that a one-time pad has perfect secrecy.

In order to effectively use a one-time pad, we need to generate a random key stream.
We then need to share the key stream to the recipient, which is exactly the initial problem.
In most applications, the one-time pad is not practical.
Instead, we share an initial fill \( k_0, \dots, k_{d-1} \) to be used in a shared feedback shift register of length \( d \) to generate \( k \).
We then apply the following result.
\begin{lemma}
    Let \( x_0, x_1, \dots \) be a stream in \( \mathbb F_2 \) produced by a feedback shift register of length \( d \).
    Then there exist \( M, N \leq 2^d \) such that \( x_{N+r} = X_{r} \) for all \( r \geq M \).
\end{lemma}
\begin{proof}
    Let the register be \( f \colon \mathbb F_2^d \to \mathbb F_2^d \), and let \( v_i = (x_i, \dots, x_{i+d-1}) \).
    Then for all \( i \), we have \( f(v_i) = v_{i+1} \).
    Since \( \abs{\mathbb F_2^d} = 2^d \), the tuples \( v_0, v_1, \dots, v_{2^d} \) cannot all be distinct.
    Let \( a < b \leq 2^d \) such that \( v_a = v_b \).
    Let \( M = a \) and \( N = b - a \), so \( v_M = v_{M+N} \) so by induction we have \( v_r = v_{r+N} \) for all \( r \geq M \).
\end{proof}
\begin{remark}
    The maximum period of a feedback shift register of length \( d \) is \( 2^d \).
    For a linear feedback shift register, the maximum period is \( 2^d - 1 \); this result is shown on the fourth example sheet.
    
    Stream ciphers using linear feedback shift registers fail at level 2 due to the Berlekamp--Massey method.
    However, this cryptosystem is cheap, fast, and easy to use.
    Encryption and decryption can be performed on-the-fly, without needing the entire codeword first, and it is error-tolerant.
\end{remark}
Recall that the stream produced by a linear feedback shift register is given by \( x_n = \sum_{i=1}^d a_{d-i} x_{n-i} \) for all \( n \geq d \), and has auxiliary polynomial \( P(X) = X^d + a_{d-1}X^{d-1} + \dots + a_0 \) with \( a_d = 1 \).
The solutions to the recursion relations are linear combinations of powers of roots of \( P \).
Over \( \mathbb C \), the general solution is a linear combination of \( \alpha^n, n\alpha^n, \dots, n^{t-1} \alpha^n \) where \( \alpha \) is a root of \( P(X) \) with multiplicity \( t \).

As \( n^2 = n \) in \( \mathbb F_2 \), we cannot use this method directly.
First, we must work in a splitting field \( K \) of \( P \), a field containing \( \mathbb F_2 \) in which \( P \) is expressible as a product of linear factors.
In addition, we replace the \( n^i \alpha^n \) term with \( \binom{n}{i} \alpha^n \).
The general solution is now a linear combination of these terms in \( K \).

We can also generate new key streams from old ones.
\begin{lemma}
    Let \( (x_n) \), \( (y_n) \) be outputs from linear feedback shift registers of length \( M, N \) respectively.
    Then,
    \begin{enumerate}
        \item the sequence \( (x_n + y_n) \) is the output of a linear feedback shift register of length \( M + N \);
        \item the sequence \( (x_n y_n) \) is the output of a linear feedback shift register of length \( MN \).
    \end{enumerate}
\end{lemma}
The following proof is non-examinable.
\begin{proof}
    Assume for simplicity that the auxiliary polynomials \( P(X), Q(X) \) each have distinct roots \( \alpha_1, \alpha_M \) and \( \beta_1, \dots, \beta_N \) in a field \( K \) extending \( \mathbb F_2 \).
    Then \( x_n = \sum_{i=1}^M \lambda_i \alpha_i^n \) and \( y_n = \sum_{i=1}^N \mu_j \beta_j^n \) where \( \lambda_i, \mu_j \in K \).
    Now, \( x_n + y_n = \sum_{i=1}^M \lambda_i \alpha_i^n \sum_{i=1}^N \mu_j \beta_j^n \) is produced by a linear feedback shift register with auxiliary polynomial \( P(X) Q(X) \).
    For the second part, \( x_n y_n = \sum_{i=1}^M \sum_{j=1}^n \lambda_i \mu_j (\alpha_i \beta_j)^n \) is the output of a linear feedback shift register with auxiliary polynomial \( \prod_{i=1}^N \prod_{j=1}^M (X - \alpha_i \beta_j) \).
\end{proof}
Adding outputs of linear feedback shift registers is no more economical than producing the same string with a single linear feedback shift register.
Muliplying streams does increase the effective length of the linear feedback shift register, but \( x_n y_n = 0 \) when either \( x_n \) or \( y_n \) are zero, so we gain little extra data.
Nonlinear feedback shift registers are in general hard to analyse; in particular, an eavesdropper may understand the feedback shift register better than Alice and Bob.

\subsection{Asymmetric ciphers}
Stream ciphers are examples of symmetric cryptosystems.
In such a system, the decryption process is the same, or is easily deduced from, the encryption process.
In an asymmetric cryptosystem, the key is split into two parts: the \emph{private key} for decryption, and the \emph{public key} for encryption.
Knowing the encryption and decryption processes and the public key, it should still be hard to find the private key or to decrypt the messages.
This aim implies security at level 3.
In this case, there is also no key exchange problem, since the public key can be broadcast on an open channel.

We base asymmetric cryptosystems on certain mathematical problems in number theory which are believed to be `hard', such as the following.
\begin{enumerate}
    \item Factoring.
    Let \( N = pq \) for \( p, q \) large prime numbers.
    Given \( N \), the task is to find \( p \) and \( q \).
    \item Discrete logarithm problem.
    Let \( p \) be a large prime and \( g \) be a primitive root mod \( p \) (a generator of \( \mathbb F_p^\star \)).
    Given \( x \), we wish to find \( a \) such that \( x \equiv g^a \) mod \( p \).
\end{enumerate}
\begin{definition}
    An algorithm runs in \emph{polynomial time} if the number of operations needed to perform the algorithm is at most \( c N^d \) where \( N \) is the input size, and \( c, d \) are constants.
\end{definition}
\begin{example}
    An algorithm for factoring \( N \) has input size \( \log_2 N \), roughly the number of bits in its binary expansion.
    Polynomial time algorithms include arithmetic operations on integers including the division algorithm, computation of greatest common divisors, and the Euclidean algorithm.
    We can also compute \( x^\alpha \) mod \( N \) in polynomial time using repeated squaring; this is called modular exponentiation.
    Primality testing can be performed in polynomial time.

    Polynomial time algorithms are not known for examples (i) and (ii) above.
    However, we have elementary methods for computing (i) and (ii) that take exponential time.
    If \( N = pq \), dividing \( N \) by successive primes up to \( \sqrt{N} \) will find \( p \) and \( q \) but takes \( O(\sqrt{N}) = O(2^{\frac{B}{2}}) \) steps where \( B = \log_2 N \).
    
    We describe the \emph{baby-step, giant-step} algorithm for the discrete logarithm problem.
    Set \( m = \ceil{\sqrt{p}} \), and write \( a = qm + r \) for \( 0 \leq q, r < m \).
    Then, \( x \equiv g^a = g^{qm + r} \) mod \( p \), so \( g^{qm} = g^{-r} x \) mod \( p \).
    We list all values of \( g^{qm} \) and \( g^{-r}x \) mod \( p \); we then sort the lists and search for a match.
    This takes \( O(\sqrt{p}\log p) \) steps.

    The best known methods for solving the examples above use a factor base method, called the \emph{modular number sieve}.
    It has running time
    \[ O\qty(\exp(c (\log N)^{\frac{1}{3}} (\log \log N)^{\frac{2}{3}})) \]
    where \( c \) is a known constant.
\end{example}

\subsection{Rabin cryptosystem}
Recall that \emph{Euler's totient function} is denoted \( \varphi \), where \( \varphi(n) \) is the number of integers less than \( n \) which are coprime to \( n \).
Equivalently, \( \varphi(n) = \abs{\qty(\faktor{\mathbb Z}{n\mathbb Z})^\times} \).
By Lagrange's theorem, \( a^{\varphi(N)} \equiv 1 \) mod \( N \) for each \( a \) coprime to \( N \); this result is sometimes known as the Fermat--Euler theorem.
If \( N = p \) is prime, \( a^{p-1} \equiv 1 \) mod \( p \), which is Fermat's little theorem.
\begin{lemma}
    Let \( p = 4k - 1 \) be a prime, and let \( d \in \mathbb Z \).
    If \( x^2 \equiv d \) mod \( p \) is soluble, one solution is \( x \equiv d^k \) mod \( p \).
\end{lemma}
\begin{proof}
    Suppose \( x_0 \) is a solution, so \( x_0^2 \equiv d \) mod \( p \).
    Without loss of generality we can assume \( x_0 \not\equiv 0 \), or equivalently, \( x_0 \nmid p \).
    Then \( x_0^2 \equiv d \) so \( d^{2k-1} \equiv x_0^{2(2k-1)} \equiv x_0^{p-1} \equiv 1 \).
    Hence, \( \qty(d^k)^2 \equiv d \).
\end{proof}
In the Rabin cryptosystem, the private key consists of two large distinct primes \( p, q \equiv 3 \) mod 4.
The public key is \( N = pq \).
\( \mathcal M = \mathcal C = \qty{1, \dots, N-1} = \mathbb Z_N^\times \).
We encrypt a plaintext message \( m \) as \( c = m^2 \) mod \( N \).
Usually, we restrict our messages so that \( (m, N) = 1 \) and \( m > \sqrt{N} \).

Receiving ciphertext \( c \), we can solve for \( x_1, x_2 \) such that \( x_1^2 \equiv c \) mod \( p \) and \( x_2^2 \equiv c \) mod \( q \) using the previous lemma.
Then, applying the Chinese remainder theorem, we can find \( x \) such that \( x \equiv x_1 \) mod \( p \) and \( x \equiv x_2 \) mod \( q \), hence \( x^2 \equiv c \) mod \( N \).
Indeed, running the Euclidean algorithm on \( p, q \) gives integers \( r, s \) such that \( rp + sq = 1 \), then we can take \( x = sqx_1 + rpx_2 \).
\begin{lemma}
    \begin{enumerate}
        \item Let \( p \) be an odd prime, and let \( (d, p) = 1 \).
        Then \( x^2 \equiv d \) mod \( p \) has no solutions or exactly two solutions.
        \item Let \( N = pq \) where \( p, q \) are distinct odd primes, and let \( (d, N) = 1 \).
        Then \( x^2 \equiv d \) mod \( N \) has no solutions or exactly four solutions.
    \end{enumerate}
\end{lemma}
\begin{proof}
    \emph{Part (i).}
    \( x^2 \equiv y^2 \) mod \( p \) if and only if \( p \mid (x^2 - y^2) = (x-y)(x+y) \), so either \( p \mid x-y \) or \( p \mid x+y \), so \( x = \pm y \).
    
    \emph{Part (ii).}
    If \( x_0 \) is a solution, then by the Chinese remainder theorem, there exist solutions \( x \) with \( x \equiv \pm x_0 \) mod \( p \) and \( x \equiv \pm x_0 \) mod \( q \).
    This gives four solutions as required.
    By (i), these are the only possible solutions.
\end{proof}
Hence, to decrypt the Rabin cipher, we must find all four solutions to \( x^2 \equiv c \) mod \( N \).
Messages should include enough redundancy to uniquely determine which of these four solutions is the intended plaintext.
\begin{theorem}
    Breaking the Rabin cryptosystem is essentially as difficult as factoring \( N \).
\end{theorem}
\begin{proof}
    If we can factorise \( N \) as \( pq \), we have seen that we can decrypt messages.
    Conversely, suppose we can break the cryptosystem, so we have an algorithm to find square roots modulo \( N \).
    Choose \( x \) mod \( N \) at random, and use the algorithm to find \( y \) such that \( y^2 \equiv x^2 \) mod \( N \).
    With probability \( \frac{1}{2} \), \( x \neq \pm y \) mod \( N \).
    Then, \( (N, x-y) \) is a nontrivial factor of \( N \).
    If this fails, choose another \( x \), and repeat until the probability of failure \( \qty(\frac{1}{2})^r \) is acceptably low.
\end{proof}

\subsection{RSA cryptosystem}
Suppose \( N = pq \) where \( p, q \) are distinct odd primes.
We claim that if we know a multiple \( m \) of \( \varphi(N) = (p-1)(q-1) \), then factoring \( N \) is `easy'.
Write \( o_p(x) \) for the order of \( x \) as an element of \( \qty(\faktor{\mathbb Z}{p\mathbb Z})^\times \).
Write \( m = 2^a b \) where \( a \geq 1, b \) odd.
Let
\[ X = \qty{x \in \qty(\faktor{\mathbb Z}{N\mathbb Z})^\times \midd o_p(x^b) \neq o_q(x^b)} \]
\begin{theorem}
    \begin{enumerate}
        \item If \( x \in X \), then there exists \( 0 \leq t < a \) such that \( (x^{2^t b} - 1, N) \) is a nontrivial factor of \( N \).
        \item \( \abs{X} \geq \frac{1}{2} \abs{\qty(\faktor{\mathbb Z}{n\mathbb N})^\times} = \frac{1}{2}(p-1)(q-1) \).
    \end{enumerate}
\end{theorem}
\begin{proof}
    \emph{Part (i).}
    By the Fermat--Euler theorem, \( x^{\varphi(N)} \equiv 1 \) mod \( N \).
    Hence \( x^m \equiv 1 \) mod \( N \).
    But \( m = 2^a b \), so setting \( y = x^b \) mod \( N \), we obtain \( y^{2^a} \equiv 1 \) mod \( N \).
    In particular, \( o_p(y) \) and \( o_q(y) \) are powers of 2.
    Since \( x \in X \), \( o_p(y) \neq o_q(y) \), so without loss of generality suppose \( o_p(y) < o_q(y) \).
    Let \( o_p(y) = 2^t \), so \( 0 \leq t < a \).
    Then \( y^{2^t} \equiv 1 \) mod \( p \), but \( y^{2^t} \not\equiv 1 \) mod \( q \).
    So \( (y^{2^t} - 1, N) = p \) as required.
\end{proof}
The proof of part (ii) will be seen later.

In the RSA cryptosystem, the private key consists of large distinct primes \( p, q \) chosen at random.
Let \( N = pq \), and choose the \emph{encrypting exponent} \( e \) randomly such that \( (e, \varphi(N)) = 1 \), for instance taking \( e \) prime larger than \( p, q \).
By Euclid's algorithm, there exist \( d, k \) such that \( de - k\varphi(N) = 1 \); \( d \) is called the \emph{decrypting exponent}.

The public key is \( (N, e) \), and we encrypt \( m \in \mathcal M \) as \( c \equiv m^e \) mod \( N \).
The private key is \( (N, d) \), and we decrypt \( c \in \mathcal C \) as \( x \equiv c^d \) mod \( N \).
By the Fermat--Euler theorem, \( x \equiv m^{de} \equiv m^{1+k\varphi(N)} \equiv m \) mod \( N \), noting that the probability that \( (m, N) \neq 1 \) is small enough to be ignored.
Hence, the decrypting function is inverse to the encrypting function.
% 
% Suppose that Eve intercepts the ciphertext \( c \), and wants to find the plaintext given the public key \( (N, e) \).
% This problem is essentially as difficult as finding the factors \( p \) and \( q \) of \( N \) so that \( \varphi(N) = (p-1)(q-1) \) can be computed.
\begin{corollary}
    Finding the RSA private key \( (N, d) \) is essentially as difficult as factoring \( N \).
\end{corollary}
\begin{proof}
    We have already shown that if we can factorise \( N \), we can find \( d \).
    Conversely, suppose there is an algorithm to find \( d \) given \( N \) and \( e \).
    Then \( de \equiv 1 \) mod \( \varphi(N) \).
    Taking \( m = de-1 \) in the proof of part (i) of the theorem above, we can factorise \( N \).
    If this fails, repeat until the probability of failure is acceptably low.
\end{proof}
