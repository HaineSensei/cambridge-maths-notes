\subsection{Cryptosystems}
We want to modify a message such that it becomes unintelligible to an eavesdropper Eve.
Certain secret information is shared between two participants Alice and Bob, called the \emph{key}, chosen from a set of possible keys \( \mathcal K \).
The unencrypted message is called the \emph{plaintext}, which lies in a set \( \mathcal M \), and the encrypted message is called the \emph{ciphertext}, and lies in a set \( \mathcal C \).
A \emph{cryptosystem} consists of \( (\mathcal K, \mathcal M, \mathcal C) \) together with the \emph{encryption} function \( e \colon \mathcal M \times \mathcal K \to \mathcal C \) and \emph{decryption} function \( d \colon \mathcal C \times \mathcal K \to \mathcal M \).
These maps have the property that \( d(e(m, k), k) = m \) for all \( m \in \mathcal M, k \in \mathcal K \).
\begin{example}
    Suppose \( \mathcal M = \mathcal C = \qty{A, B, \dots, Z}^\star = \Sigma^\star \).
    The \emph{simple substitution cipher} defines \( \mathcal K \) to be the set of permutations of \( \Sigma \).
    To encrypt a message, each letter of plaintext is replaced with its image under a chosen permutation \( \pi \in \mathcal K \).

    The \emph{Vigen\`ere} cipher has \( \mathcal K = \Sigma^d \) for some \( d \).
    We identify \( \Sigma \) and \( \faktor{\mathbb Z}{26\mathbb Z} \).
    Write out the key repeatedly below the plaintext, and add each plaintext letter with the corresponding key letter to produce a letter of ciphertext.
    For instance, encrypting the plaintext ATTACKATDAWN with the key LEMON gives ciphertext LXFOPVEFRNHR.
    Note, for instance, that each occurrence of the letter A in the plaintext corresponds to a letter of the key in the ciphertext.
    If \( d = 1 \), this is the \emph{Caesar cipher}.
\end{example}

\subsection{Breaking cryptosystems}
Eve may know \( e \) and \( d \), as well as the probability distributions of \( \mathcal K, \mathcal M \), but she does not know the key itself.
She seeks to recover the plaintext from a given string of ciphertext.
There are three possible attack levels.
\begin{enumerate}[1.]
    \item (ciphertext-only) Eve only knows some piece of ciphertext.
    \item (known-plaintext) Eve knows a considerable length of plaintext and its corresponding ciphertext, but not the key.
    In other words, she knows \( m \) and \( e(m,k) \), but not \( k \).
    \item (chosen plaintext) Eve can acquire the ciphertext for any plaintext message; she can generate \( e(m,k) \) for any \( m \).
\end{enumerate}
\begin{remark}
    The simple substitution cipher and Vigen\`ere cipher fail at Level 1 in English if the messages are sufficiently long, as we can perform frequency analysis.
    Even if the plaintext is suitably random, both examples can fail at Level 2.
    For modern applications, Level 3 security is desirable.
\end{remark}
% TODO: too little indent in enumerate above
Consider a cryptosystem \( (\mathcal M, \mathcal K, \mathcal C) \).
We model the keys and messages as independent random variables \( K, M \) taking values in \( \mathcal K, \mathcal M \).
The ciphertext random variable is \( C = e(K,M) \in \mathcal C \).
\begin{definition}
    A cryptosystem \( (\mathcal M, \mathcal K, \mathcal C) \) has \emph{perfect secrecy} if \( H(M \mid C) = H(M) \), or equivalently, \( M \) and \( C \) are independent, or \( I(M;C) = 0 \).
\end{definition}
One can show that perfect secrecy implies that \( \abs{\mathcal K} \geq \abs{\mathcal M} \).
\begin{definition}
    The \emph{message equivocation} is \( H(M \mid C) \).
    The \emph{key equivocation} is \( H(K \mid C) \).
\end{definition}
\begin{lemma}
    \( H(M \mid C) \leq H(K \mid C) \).
\end{lemma}
\begin{proof}
    Note that \( M = d(C,K) \), hence \( H(M \mid C, K) = 0 \).
    Therefore, \( H(C,K) = H(M,C,K) \).
    So
    \[ H(K \mid C) = H(K,C) - H(C) = H(M,C,K) - H(M \mid K,C) - H(C) = H(M,K,C) - H(C) = H(K \mid M,C) + H(M,C) - H(C) = H(K \mid M, C) + H(M \mid C) \]
    Hence \( H(K \mid C) \geq H(M \mid C) \).
\end{proof}
Let \( \mathcal M = \mathcal C = \mathcal A \), and suppose we send \( n \) messages modelled as \( M^{(n)} = (M_1, \dots, M_n) \) encrypted as \( C^{(n)} = (C_1, \dots, C_n) \) using the same key \( K \).
\begin{definition}
    The \emph{unicity distance} is the least \( n \) such that \( H(K \mid C^{(n)}) = 0 \); it is the smallest number of encrypted messages required to uniquely determine the key.
\end{definition}
Now,
\[ H(K \mid C^{(n)}) = H(K, C^{(n)}) - H(C^{(n)}) = H(K, M^{(n)}, C^{(n)}) - H(C^{(n)}) = H(K, M^{(n)}) - H(C^{(n)}) = H(K) + H(M^{(n)}) - H(C^{(n)}) \]
as \( K, M^{(n)} \) are independent.
We make the following assumptions.
\begin{enumerate}
    \item All keys are equally likely, so \( H(K) = \log \abs{\mathcal K} \).
    \item \( H(M^{(n)}) \approx nH \) for some constant \( H \) and sufficiently large \( n \).
    \item All sequences of ciphertext are equally likely, so \( H(C^{(n)}) = n \log \abs{\mathcal A} \).
\end{enumerate}
Hence,
\[ H(K \mid C^{(n)}) = \log \abs{\mathcal K} + nH - n \log \abs{\mathcal A} \geq 0 \]
This holds if and only if
\[ n \leq U = \frac{\log \abs{\mathcal K}}{\log \abs{\mathcal A} - H} \]
Equivalently, \( \frac{\log \abs{\mathcal A}}{R\log \abs{\mathcal A}} \) where \( R = 1 - \frac{H}{\log \abs{\mathcal A}} \) is the \emph{redundancy} of the source.
Recall that \( 0 \leq H \leq \log \abs{\mathcal A} \).
To make the unicity distance large, we can make the number of keys large, or use a message source with little redundancy.

\subsection{One-time pad}
Consider streams in \( \mathbb F_2 \) representing the plaintext \( p_0, p_1, \dots \), the key stream \( k_0, k_1, \dots \), and the ciphertext \( z_0, z_1, \dots \) where \( z_n = p_n + k_n \).
\begin{definition}
    A \emph{one-time pad} is a cryptosystem where \( k \) is generated randomly; the \( k_i \) are independent and take values of 0 or 1 with probability \( \frac{1}{2} \).
\end{definition}
\( z = p + k \) is now a stream of independent and identically distributed random variables taking values of 0 or 1 with probability \( \frac{1}{2} \).
Hence, without the key stream, deciphering is impossible, so the unicity distance is infinite.
One can show that a one-time pad has perfect secrecy.

In order to effectively use a one-time pad, we need to generate a random key stream.
We then need to share the key stream to the recipient, which is exactly the initial problem.
In most applications, the one-time pad is not practical.
Instead, we share an initial fill \( k_0, \dots, k_{d-1} \) to be used in a shared feedback shift register of length \( d \) to generate \( k \).
We then apply the following result.
\begin{lemma}
    Let \( x_0, x_1, \dots \) be a stream in \( \mathbb F_2 \) produced by a feedback shift register of length \( d \).
    Then there exist \( M, N \leq 2^d \) such that \( x_{N+r} = X_{r} \) for all \( r \geq M \).
\end{lemma}
\begin{proof}
    Let the register be \( f \colon \mathbb F_2^d \to \mathbb F_2^d \), and let \( v_i = (x_i, \dots, x_{i+d-1}) \).
    Then for all \( i \), we have \( f(v_i) = v_{i+1} \).
    Since \( \abs{\mathbb F_2^d} = 2^d \), the tuples \( v_0, v_1, \dots, v_{2^d} \) cannot all be distinct.
    Let \( a < b \leq 2^d \) such that \( v_a = v_b \).
    Let \( M = a \) and \( N = b - a \), so \( v_M = v_{M+N} \) so by induction we have \( v_r = v_{r+N} \) for all \( r \geq M \).
\end{proof}
\begin{remark}
    The maximum period of a feedback shift register of length \( d \) is \( 2^d \).
    For a linear feedback shift register, the maximum period is \( 2^d - 1 \); this result is shown on the fourth example sheet.
    
    Stream ciphers using linear feedback shift registers fail at level 2 due to the Berlekamp--Massey method.
    However, this cryptosystem is cheap, fast, and easy to use.
    Encryption and decryption can be performed on-the-fly, without needing the entire codeword first, and it is error-tolerant.
\end{remark}
Recall that the stream produced by a linear feedback shift register is given by \( x_n = \sum_{i=1}^d a_{d-i} x_{n-i} \) for all \( n \geq d \), and has auxiliary polynomial \( P(X) = X^d + a_{d-1}X^{d-1} + \dots + a_0 \) with \( a_d = 1 \).
The solutions to the recursion relations are linear combinations of powers of roots of \( P \).
Over \( \mathbb C \), the general solution is a linear combination of \( \alpha^n, n\alpha^n, \dots, n^{t-1} \alpha^n \) where \( \alpha \) is a root of \( P(X) \) with multiplicity \( t \).

As \( n^2 = n \) in \( \mathbb F_2 \), we cannot use this method directly.
First, we must work in a splitting field \( K \) of \( P \), a field containing \( \mathbb F_2 \) in which \( P \) is expressible as a product of linear factors.
In addition, we replace the \( n^i \alpha^n \) term with \( \binom{n}{i} \alpha^n \).
The general solution is now a linear combination of these terms in \( K \).

We can also generate new key streams from old ones.
\begin{lemma}
    Let \( (x_n) \), \( (y_n) \) be outputs from linear feedback shift registers of length \( M, N \) respectively.
    Then,
    \begin{enumerate}
        \item the sequence \( (x_n + y_n) \) is the output of a linear feedback shift register of length \( M + N \);
        \item the sequence \( (x_n y_n) \) is the output of a linear feedback shift register of length \( MN \).
    \end{enumerate}
\end{lemma}
The following proof is non-examinable.
\begin{proof}
    Assume for simplicity that the auxiliary polynomials \( P(X), Q(X) \) each have distinct roots \( \alpha_1, \alpha_M \) and \( \beta_1, \dots, \beta_N \) in a field \( K \) extending \( \mathbb F_2 \).
    Then \( x_n = \sum_{i=1}^M \lambda_i \alpha_i^n \) and \( y_n = \sum_{i=1}^N \mu_j \beta_j^n \) where \( \lambda_i, \mu_j \in K \).
    Now, \( x_n + y_n = \sum_{i=1}^M \lambda_i \alpha_i^n \sum_{i=1}^N \mu_j \beta_j^n \) is produced by a linear feedback shift register with auxiliary polynomial \( P(X) Q(X) \).
    For the second part, \( x_n y_n = \sum_{i=1}^M \sum_{j=1}^n \lambda_i \mu_j (\alpha_i \beta_j)^n \) is the output of a linear feedback shift register with auxiliary polynomial \( \prod_{i=1}^N \prod_{j=1}^M (X - \alpha_i \beta_j) \).
\end{proof}
Adding outputs of linear feedback shift registers is no more economical than producing the same string with a single linear feedback shift register.
Muliplying streams does increase the effective length of the linear feedback shift register, but \( x_n y_n = 0 \) when either \( x_n \) or \( y_n \) are zero, so we gain little extra data.
Nonlinear feedback shift registers are in general hard to analyse; in particular, an eavesdropper may understand the feedback shift register better than Alice and Bob.

\subsection{Asymmetric ciphers}
Stream ciphers are examples of symmetric cryptosystems.
In such a system, the decryption process is the same, or is easily deduced from, the encryption process.
In an asymmetric cryptosystem, the key is split into two parts: the \emph{private key} for decryption, and the \emph{public key} for encryption.
Knowing the encryption and decryption processes and the public key, it should still be hard to find the private key or to decrypt the messages.
This aim implies security at level 3.
In this case, there is also no key exchange problem, since the public key can be broadcast on an open channel.

We base asymmetric cryptosystems on certain mathematical problems in number theory which are believed to be `hard', such as the following.
\begin{enumerate}
    \item Factoring.
    Let \( N = pq \) for \( p, q \) large prime numbers.
    Given \( N \), the task is to find \( p \) and \( q \).
    \item Discrete logarithm problem.
    Let \( p \) be a large prime and \( g \) be a primitive root mod \( p \) (a generator of \( \mathbb F_p^\star \)).
    Given \( x \), we wish to find \( a \) such that \( x \equiv g^a \) mod \( p \).
\end{enumerate}
\begin{definition}
    An algorithm runs in \emph{polynomial time} if the number of operations needed to perform the algorithm is at most \( c N^d \) where \( N \) is the input size, and \( c, d \) are constants.
\end{definition}
\begin{example}
    An algorithm for factoring \( N \) has input size \( \log_2 N \), roughly the number of bits in its binary expansion.
    Polynomial time algorithms include arithmetic operations on integers including the division algorithm, computation of greatest common divisors, and the Euclidean algorithm.
    We can also compute \( x^\alpha \) mod \( N \) in polynomial time using repeated squaring; this is called modular exponentiation.
    Primality testing can be performed in polynomial time.

    Polynomial time algorithms are not known for examples (i) and (ii) above.
    However, we have elementary methods for computing (i) and (ii) that take exponential time.
    If \( N = pq \), dividing \( N \) by successive primes up to \( \sqrt{N} \) will find \( p \) and \( q \) but takes \( O(\sqrt{N}) = O(2^{\frac{B}{2}}) \) steps where \( B = \log_2 N \).
    
    We describe the \emph{baby-step, giant-step} algorithm for the discrete logarithm problem.
    Set \( m = \ceil{\sqrt{p}} \), and write \( a = qm + r \) for \( 0 \leq q, r < m \).
    Then, \( x \equiv g^a = g^{qm + r} \) mod \( p \), so \( g^{qm} = g^{-r} x \) mod \( p \).
    We list all values of \( g^{qm} \) and \( g^{-r}x \) mod \( p \); we then sort the lists and search for a match.
    This takes \( O(\sqrt{p}\log p) \) steps.

    The best known methods for solving the examples above use a factor base method, called the \emph{modular number sieve}.
    It has running time
    \[ O\qty(\exp(c (\log N)^{\frac{1}{3}} (\log \log N)^{\frac{2}{3}})) \]
    where \( c \) is a known constant.
\end{example}
