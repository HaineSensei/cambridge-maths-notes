\subsection{Classical computation}
A \emph{computational task} takes an input bit string and produces an output bit string.

A decision problem is a computational task that produces an output of length 1.
Let \( B = B_1 = \qty{0,1} \) and denote \( B_n = \qty{0,1}^n \).
Define \( B^\star = \bigcup_{n \geq 1} B_n \).
A \emph{language} is a subset \( L \subseteq B^\star \).
A decision problem corresponds to the problem of checking whether a word \( w \in B^\star \) lies in a language \( L \).
For example, the set of primes, expressed in binary, forms a language \( P \subseteq B^\star \), and there is a corresponding decision problem to check if a given binary string represents a prime.

More generally, the output of a computational task can be of any length.
For example, the task \( \mathsf{FACTOR}(x) \) takes the input \( x \) and produces a bit string containing a factor of \( x \), or 1 if \( x \) is prime.

There are various models of computation, but we restrict to the \emph{circuit} model or \emph{gate array} model.
In this model, we have an input \( x = b_1 \dots b_n \in B_n \), and extend it with some trailing zeroes to add scratch space to perform computations.
We then perform a computational step, an application of designated Boolean gates \( f \colon B_n \to B_m \) on preassigned bits.
For each \( n \), we have a circuit \( C_n \), which is a prescribed sequence of computational steps that performs a given task for all inputs of size \( n \).
The output to the computation is a designated subsequence of the extended bit string.

Suppose that, in addition to extending the input bit string with zeroes, we also add \( k \) random bits, which have values set to 0 or 1 uniformly at random.
The output of the computation will now be probabilistic.
The probability that the output is \( y \) is \( a2^{-k} \), where \( a \) is the number of bit strings \( r \) that produce the desired outcome.
We typically require that the output is correct with some prescribed probability.

\subsection{Classical complexity}
The \emph{time complexity} is a measure of the amount of computational steps required for a particular algorithm for an input of size \( n \).
In the circuit model, we define \( T(n) \) to be the total number of gates in the circuit \( C_n \), known as the \emph{size} of the circuit or \emph{runtime} of the algorithm.

For a positive function \( T(n) \), we write \( T(n) = O(f(n)) \) if there exist positive constants \( c, n_0 \) such that for all \( n > n_0 \), we have \( T(n) \leq cf(n) \).
If \( T(n) = O(n^k) \) for some \( k > 0 \), we say that \( T(n) \) is \( O(\mathrm{poly}(n)) \), and the corresponding algorithm is a \emph{poly-time} algorithm.
The class of languages for which the membership problem has a classical poly-time algorithm is called \( \mathsf{P} \).
The class of languages for which the membership problem has a randomised classical poly-time algorithm that gives the correct answer with probability at least \( \frac{2}{3} \) is called \( \mathsf{BPP} \), short for \emph{bounded-error probabilistic poly-time}.
The problem \( \mathsf{FACTOR}(M,N) \) which determined if there is a nontrivial factor of \( N \) that is at most \( M \) does not lie in \( \mathsf{BPP} \).
The best known runtime is \( T(n) = O\qty(n^{\frac{1}{3}}\qty(\log n)^\frac{2}{3}) \).

A black box promise problem is a computational task where the input is a \emph{black box} or \emph{oracle} which can compute a Boolean function \( f \colon B_m \to B_n \), and there is an \emph{a priori promise} on \( f \) restricting the possible values of \( f \).
For example, the black box promise problem for constant vs.\ balanced functions takes a function \( f \colon B_n \to B \) such that \( f \) is constant or \emph{balanced}, in which case \( f \) is equal to zero for exactly half of the \( 2^n \) possible inputs.

The corresponding complexity is called \emph{query complexity}, which counts the amount of times we need to query the black box.
We typically wish to minimise the query complexity.

\subsection{Quantum circuits}
In a quantum circuit, we have qubit inputs \( \ket{b_1} \dots \ket{b_n} \ket{0} \dots \ket{0} \) analogously to the classical case.
The input size \( n \) is the number of qubits.
The addition of randomness to classical computation needs no analogue in the quantum case, since randomness is obtained by measurement.
For instance, if we have a qubit \( \ket{0} \), we can generate a uniform Bernoulli random variable by sending the qubit through a Hadamard gate and then measuring in the computational basis.

The computational steps are gates or unitary operators, which act on a prescribed set of qubits, which constitute a quantum circuit \( C_n \).
The output is obtained by performing a measurement on a prescribed set of qubits.
One can show that any circuit involving arbitrarily many measurements is equivalent to a circuit that only performs a single measurement at the end of the computation.

\subsection{Quantum oracles}
Note that all quantum gates are invertible, as they are represented with unitary operators, but not all classical gates are invertible.
Any \( f \colon B_m \to B_n \) can be expressed in an equivalent invertible form \( \widetilde f \colon B_{m+n} \to B_{m+n} \) by defining \( \widetilde f(b,c) = (b, c \oplus f(b)) \).
If we can compute \( f \) we can also compute \( \widetilde f \), and conversely given \( \widetilde f \) we can find \( f(b) = \widetilde f(b.0) \).
This is self-inverse.
\[ \widetilde f(\widetilde f(b,c)) = \widetilde f(b, c \oplus f(b)) = (b, c \oplus f(b) \oplus f(b)) = (b, c) \]
A quantum oracle for a function \( f \colon B_m \to B_n \) is the quantum gate \( U_f \) acting on \( m + n \) qubits such that \( U_f \ket{x} \ket{y} = \ket{x} \ket{y \oplus f(x)} \) for \( \ket{x}, \ket{y} \) states in the computational basis.
In other words, its action on the computational basis is \( \widetilde f \).
We say that \( \ket{x} \) is the \emph{input register} and \( \ket{y} \) is the \emph{output register}.

One can show that \( U_f \) is always a unitary operator.
We can show this directly by considering \( U_f \ket{x'}\ket{y'} = \ket{x'}\ket{y' \oplus f(x')} \), and we can take the inner product with \( U_f \ket{x} \ket{y} = \ket{x} \ket{y \oplus f(x)} \).
An easier way to show this is to consider \( \widetilde f \colon B_k \to B_k \) as a permutation on \( B_k \) where \( m + n = k \).
We can write \( U_f \ket{x} \ket{y} = U_f \ket{i_1 \dots i_k} = \ket{\widetilde f(i_1 \dots i_k)} \).
Since \( \widetilde f \) is a permutation, \( U_f \) is therefore represented by a permutation matrix, which has a single 1 in each row and column.
All permutation matrices are unitary.

In contrast to a classical oracle, a quantum oracle can act on a superposition of input registers.
Let \( f \colon B_m \to B_n \), and consider the \emph{equal superposition} state \( \ket{\varphi_m} = \frac{1}{\sqrt{2^m}} \sum_{x \in B_m} \ket{x} \).
We can find
\[ U_f \ket{\varphi_m} \ket{y} = U_f \qty( \frac{1}{\sqrt{2^m}} \sum_{x \in B_m} \ket{x}) \ket{y} = \frac{1}{\sqrt{2^m}} \sum_{x \in B_m} U_f \ket{x} \ket{y} = \ket{\psi_f} \]
In a single use of the oracle, we obtain a final state which depends on the value of \( f \) corresponding to all possible inputs.
One can easily create such an equal superposition state \( \ket{\varphi_m} \) by sending the \( m \)-qubit state \( \ket{0} \dots \ket{0} \) through \( m \) Hadamard gates \( H \otimes \dots \otimes H \).
We have \( \qty(H \ket{0})^{\otimes m} = \qty(\ket{+})^{\otimes m} = \ket{\varphi_m} \).
This creates a superposition of exponentially many terms using a linear amount of Hadamard gates.

\subsection{Deutsch--Jozsa algorithm}
Consider the black box problem for balanced vs.\ constant functions.
Classically, one needs \( 2^{n-1} + 1 \) queries to solve the problem in the worst case.
This amount of queries is clearly sufficient; even if \( f \) is balanced, the first \( 2^{n-1} \) queries could have equal outcomes, but the subsequent query must have a different outcome.
Suppose that there exists an algorithm that can solve the problem in \( 2^{n-1} \) queries.
An adversary that controls the oracle can respond with 0 for every query, and subsequently chooses a function \( f \) that agrees with the earlier query results but is balanced or constant as required to cause the algorithm to produce an error.
Therefore, classically we require a query complexity of \( O(\exp(n)) \).

Suppose we have a quantum oracle \( U_f \) with \( U_f \ket{x} \ket{y} = \ket{x} \ket{y \oplus f(x)} \), where \( \ket{x} \) is an \( n \)-qubit state and \( \ket{y} \) is a 1-qubit state.
Set each qubit to state \( \ket{0} \), then act by \( H^{\otimes n} \otimes (H \cdot X) \) on \( \ket{x} \ket{y} \).
We then obtain the state \( \ket{A} = \frac{1}{\sqrt{2^n}} \sum_{x \in B_n} \ket{x} \ket{-} \).
Send this state through the oracle to obtain \( U_f \ket{A} = \frac{1}{\sqrt{2^n}} U_f \sum_{x \in B_n} \ket{x} \ket{-} \).
Note that
\begin{align*}
    U_f \ket{x} \ket{-} &= \frac{1}{\sqrt{2}} U_f \qty(\ket{x}\ket{0} - \ket{x}\ket{1}) \\
    &= \frac{1}{\sqrt{2}} \qty(\ket{x}\ket{f(x)} - \ket{x}\ket{f(x)^c}) \\
    &= \begin{cases}
        \frac{1}{\sqrt{2}}\ket{x}(\ket{0} - \ket{1}) = \ket{x}\ket{-} & \text{if } f(x) = 0 \\
        \frac{1}{\sqrt{2}}\ket{x}(\ket{1} - \ket{0}) = -\ket{x}\ket{-} & \text{if } f(x) = 1
    \end{cases} \\
    &= (-1)^{f(x)} \ket{x}\ket{-}
\end{align*}
The method of encoding all information into a phase is called \emph{phase kickback}.
Hence,
\[ U_f \ket{A} = \frac{1}{\sqrt{2^n}} U_f \sum_{x \in B_n} \ket{x} \ket{-} = \frac{1}{\sqrt{2^n}} \qty(\sum_{x \in B_n} (-1)^{f(x)} \ket{x}) \ket{-} \]
We can then easily discard the last qubit, as it is now in a product state.
We obtain
\[ \ket{f} = \frac{1}{\sqrt{2^n}} \sum_{x \in B_n} (-1)^{f(x)} \ket{x} \]
If \( f \) is constant,
\[ \ket{f} = \pm \frac{1}{\sqrt{2^n}} \sum_{x \in B_n} \ket{x} = \pm \qty(H \ket{0})^{\otimes n} \]
If we apply \( H^{\otimes n} \) to \( \ket{f} \), we obtain \( \pm \ket{0}^{\otimes n} \).
If \( f \) is balanced, writing \( \ket{\varphi_n} = \frac{1}{\sqrt{2^n}} \sum_{y \in B_n} \ket{y} \),
\[ \ip{f}{\varphi_n} = \frac{1}{2^n} \sum_{x, y \in B_n} (-1)^{f(x)} \ip{y}{x} = \frac{1}{2^n} \sum_{x \in B_n} (-1)^{f(x)} = 0 \]
In this case, \( \ket{f} \) is orthogonal to \( \ket{\varphi_n} \).
Applying \( H^{\otimes n} \) to \( \ket{f} \), \( H^{\otimes n} \ket{f} \) is orthogonal to \( H^{\otimes n} \ket{\varphi_n} = \ket{0}^{\otimes n} \).

After obtaining \( \ket{f} \), we apply \( H^{\otimes n} \) and measure in the computational basis.
If \( f \) is constant, we measure \( 0\dots 0 \) with probability 1, and if \( f \) is balanced, we measure \( 0\dots 0 \) with probability 0.
This allows us to infer whether \( f \) is constant or balanced with probability 1.
\begin{center}
    \leavevmode
    \Qcircuit{
        \lstick{\ket{0}_1} & \qw & \gate{H} \qw & \multigate{4}{U_f} & \gate{H} & \meter \qw & \rstick{x_1} \cw \\
        \lstick{\ket{0}_2} & \qw & \gate{H} \qw & \ghost{U_f} & \gate{H} & \meter \qw & \rstick{x_2} \cw \\
        \vdots & & & & & & \vdots \\
        \lstick{\ket{0}_n} & \qw & \gate{H} \qw & \ghost{U_f} & \gate{H} & \meter \qw & \rstick{x_n} \cw \\
        \lstick{\ket{0}} & \gate{X} \qw & \gate{H} \qw & \ghost{U_f} & \rstick{\text{discard}} \qw
    }
\end{center}
For this algorithm, we use one query and \( 3n+2 \) further operations.

Suppose we permit a probability \( \varepsilon > 0 \) of error.
In the quantum case, we only need one query.
In the classical case, there is a randomised algorithm which solves the problem with a constant number \( O\qty(\log \frac{1}{\varepsilon}) \) of queries for all \( n \).
Choose \( k \) inputs each chosen uniformly at random, and evaluate \( f(x) \) for each \( x \) in this set.
If \( f(x) \) is constant for all of these \( k \) inputs, we infer \( f \) is constant; otherwise we infer it is balanced.
An error can only occur when the function is balanced but we infer it is constant.
The probability of error is \( \frac{2}{2^k} = 2^{-k+1} \).
Hence, we can take \( \varepsilon < 2^{-k+1} \), so \( k = O\qty(\log \frac{1}{\varepsilon}) \).

\subsection{Simon's algorithm}
Consider a function \( f \colon B_n \to B_n \) with the promise that either \( f \) is injective, or \( f(x) = f(y) \) if and only if \( y = x \) or \( y = x \oplus \xi \) for a fixed \( 0 \neq \xi \in B_n \).
The problem is to determine with bounded error whether \( f \) is in the 1-1 form or the 2-1 form, and in the latter case, to find the constant \( \xi \).
Note that \( f(x \oplus \xi) = f(x) \) is the statement that \( f \) has period \( \xi \).

Classically, the query complexity is \( O(\exp(n)) \).
In order to solve the problem, we need to find two distinct \( x, y \) inputs for which \( f(x) = f(y) \), or show that this is not possible.
However, there is a quantum algorithm with query complexity \( O(n) \).

\subsection{Quantum Fourier transform}
Let \( \mathcal V_N \) be a state space, and \( \mathcal B_N = \qty{\ket{0}, \ket{1}, \dots, \ket{N-1}} \) be an orthonormal basis for \( \mathcal V_N \).
Write \( \mathbb Z_N \) for integers modulo \( N \), and let \( \omega = e^{\frac{2\pi i}{N}} \).
For \( \ket{k} \in \mathcal B_N \), we define
\[ QFT_N\ket{k} = \frac{1}{\sqrt{N}} \sum_{\ell=0}^{N-1} e^{\frac{2\pi i}{N}k\ell} \ket{\ell} = \frac{1}{\sqrt{N}} \sum_{\ell=0}^{N-1} \omega^{k\ell} \ket{\ell} \]
The quantum Fourier transform can be viewed as a generalisation of the Hadamard operator, as \( QFT_2 = H \).

We show that this is a unitary operator.
\[ (QFT)_{jk} = \bra{j}QFT\ket{k} = \frac{1}{\sqrt{N}} \sum_{\ell=0}^{N-1} \omega^{k\ell} \ip{j}{\ell} = \frac{1}{\sqrt{N}} \omega^{jk} \]
\[ QFT = \frac{1}{\sqrt{N}} \begin{pmatrix}
    1 & 1 & 1 & 1 & \cdots \\
    1 & \omega & \omega^2 & \omega^3 & \cdots \\
    1 & \omega^2 & \omega^4 & \omega^6 & \cdots \\
    1 & \omega^3 & \omega^6 & \omega^9 & \cdots \\
    \vdots & \vdots & \vdots & \vdots & \ddots
\end{pmatrix} \]
Let \( S_j \) be the sum of the \( j \)th row or column.
If \( j = 0 \), \( S_j = \frac{1}{\sqrt{N}} N \).
Otherwise,
\[ S_j = \frac{1}{\sqrt{N}} (1 + \omega^j + \dots + \omega^{j(N-1)}) = \frac{1}{\sqrt{N}} \cdot \frac{1 - \omega^{jN}}{1 - \omega^j} = 0 \]
We can use this to prove that \( (QFT^\dagger QFT)_{jk} = \delta_{jk} \), so it is a unitary operator.

Suppose we have a periodic function \( f \colon \mathbb Z_N \to Y \), where typically \( Y = \mathbb Z_M \) for some \( M \).
Let \( r \) be the smallest integer in \( \mathbb Z_N \) for which \( f(x+r) = f(x) \) for all \( x \in \mathbb Z_N \), so \( f \) is periodic with period \( r \).
Suppose further that \( f \) is injective in each period.
We wish to find \( r \) with a particular probability of error.

There is a classical algorithm with query complexity \( O(\sqrt{N}) = O\qty(2^{\log N^{\frac{1}{2}}}) = O\qty(2^{\frac{1}{2} \log N}) \).
In the quantum case, for any error probability \( \varepsilon \in (0,1) \), there is an algorithm with query complexity \( O(\log \log N) \), which provides an exponential speed increase.

We first describe an attempt to construct such an algorithm without using the quantum Fourier transform.
Begin with the uniform superposition state \( \ket{\psi_N} = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} \ket{x} \).
Consider the quantum oracle \( U_f \) corresponding to \( f \colon \mathbb Z_N \to \mathbb Z_M \), defined by \( U_f \ket{x} \ket{y} = \ket{x} \ket{y + f(x)} \), where addition is performed modulo \( M \).
Set the output register \( \ket{y} \) to \( \ket{0} \), and then compute \( \ket{f} = U_f \ket{\psi_N} \ket{0} \).
We obtain
\[ \ket{f} = U_f \ket{\psi_N} \ket{0} = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} U_f \ket{x} \ket{0} = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} \ket{x} \ket{f(x)} \]
Since \( r \) is the period, we have \( r \mid N \), so let \( A = \frac{N}{r} \in \mathbb N \) be the number of periods.
We now measure the second register, giving an outcome \( y = f(x_0) \) for some \( x_0 \in \qty{0, \dots, r-1} \).
Note that \( y = f(x_0 + jr) \) for any \( j \in \qty{0, \dots, A-1} \).
The terms in \( \ket{f} \) which contribute to the outcome \( y = f(x_0) \) are
\[ \frac{1}{\sqrt{N}} \sum_{j=0}^{A-1} \ket{x_0 + jr} \ket{f(x_0)} \]
Hence, the probability of obtaining a particular outcome \( f(x_0) \) is \( \frac{A}{N} = \frac{1}{r} \).
The post-measurement state of the input register is
\[ \ket{\text{per}} = \frac{1}{\sqrt{A}} \sum_{j=0}^{A-1} \ket{x_0 + jr} \]
The state \( \ket{\text{per}} \) is periodic.
If we measure the input register, we obtain \( \ket{x_0 + j_0 r} \) for some \( j_0 \in \qty{0, \dots, A-1} \), selected uniformly at random.
The probability that the outcome of this second measurement is \( x_0 + j_0 r \) is \( \frac{1}{A} \).
Therefore, no information about \( r \) is obtained.

We resolve this issue by utilising the quantum Fourier transform.
Instead of measuring the input register, we act on \( \ket{\text{per}} \) by \( QFT_N \).
Since
\[ QFT_N\ket{x} = \frac{1}{\sqrt{N}}\sum_{y=0}^{N-1}\omega^{xy} \ket{y} \]
we find
\begin{align*}
    QFT_N \ket{\text{per}} &= \frac{1}{\sqrt{A}}\sum_{y=0}^{N-1} QFT_N \ket{x_0 + jr} \\
    &= \frac{1}{\sqrt{A}} \frac{1}{\sqrt{N}} \sum_{j=0}^{A-1} \sum_{y=0}^{N-1} \omega^{(x_0 + jr)y} \ket{y} \\
    &= \frac{1}{\sqrt{NA}} \sum_{y=0}^{N-1} \omega^{x_0 y} \underbrace{\qty[\sum_{j=0}^{A-1} \qty(\omega^{ry})^j]}_S \ket{y}
\end{align*}
Note that
\[ S = \begin{cases}
    A & \text{if } \omega^{ry} = 1 \\
    \frac{1 - \omega^{ryA}}{1 - \omega^{ry}} = 0 & \text{otherwise}
\end{cases} \]
Note that \( \omega^{ry} = 1 \) if \( y = kA = \frac{kN}{r} \) for \( k \in \qty{0, \dots, r - 1} \).
Hence, we obtain
\[ QFT_N \ket{\text{per}} = \frac{A}{\sqrt{NA}} \sum_{k=0}^{r-1} \omega^{x_0 \frac{kN}{r}} \ket{\frac{kN}{r}} = \frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} \omega^{x_0 \frac{kN}{r}} \ket{\frac{kN}{r}} \]
The value of \( x_0 \) is no longer present in a ket, and has been converted into phase information.
It therefore does not affect measurement outcomes.
The periodicity in \( r \) has been inverted into periodicity in \( \frac{1}{r} \).
The resulting state is still periodic, but each period begins at 0 instead of \( x_0 \).

Now, when measuring this register, the outcome is \( c = \frac{k_0N}{r} \) for some \( k_0 \in \qty{0, \dots, r-1} \).
Each outcome occurs with probability \( r \).
Note that \( \frac{k_0}{r} = \frac{c}{N} \), and \( \frac{c}{N} \) is known after performing the measurement; we wish to know the value of \( r \).

Suppose first that \( k_0 \) is coprime to \( r \).
In this case, we can cancel \( \frac{c}{N} \) to its lowest form, then the denominator is \( r \).
If \( k_0 \) is not coprime to \( r \), the denominator \( \widetilde r \) will instead be a factor of \( r \).
To solve this, we can compute the reduced denominator and then evaluate \( f(0), f(\widetilde r) \); if they are equal, \( \widetilde r = r \), and otherwise, \( \widetilde r \mid r \).
We would like to know the probability that a randomly chosen \( k_0 \) is coprime to the true periodicity \( r \).
\begin{theorem}[coprimality theorem]
    The number of integers less than \( r \) that are coprime to \( r \) is \( O\qty(\frac{r}{\log \log r}) \).
\end{theorem}
This theorem implies that since \( k_0 \) is chosen uniformly at random, the probability that \( k_0 \) is coprime to \( r \) is \( O\qty(\frac{1}{\log \log r}) \).
We claim that if we repeat this process \( O(\log \log r) \) times, we will obtain an outcome \( c \) such that after cancellation, \( \frac{c}{N} = \frac{k_0}{r} \) where \( k_0 \) is coprime to \( r \) in at least one case, with a constant probability.
This claim follows from the following lemma.
\begin{lemma}
    Suppose that a single trial has success probability \( p \), and the trial is repeated \( M \) times independently, for any \( \varepsilon \in (0,1) \), the probability of at least one success is greater than \( 1 - \varepsilon \) if \( M = \frac{-\log \varepsilon}{p} \).
\end{lemma}
Therefore, to achieve a constant probability \( 1 - \varepsilon \) of success, we need \( O\qty(\frac{1}{p}) \) trials.
In the algorithm above, \( p = O\qty(\frac{1}{\log \log r}) \), so we need \( O(p) = O(\log \log r) < O(\log \log N) \) trials to achieve the desired result.

In each invocation of the algorithm, we query \( f \) three times: once to construct the state \( \ket{f} \), and twice to check if \( \widetilde r \) is the true periodicity.
We also need to apply the quantum Fourier transform \( QFT_N \), which has implementations in \( O((\log N)^2) \) steps.
We must also perform standard arithmetic operations such as to cancel denominators, which are computable in \( O(\mathrm{poly}(\log N)) \) steps.
Therefore, we succeed in determining the period with any constant probability of success \( 1 - \varepsilon \) with \( O(\log \log N) \) queries and \( O(\mathrm{poly}(\log N)) \) additional steps.
