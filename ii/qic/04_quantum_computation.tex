\subsection{Classical computation}
A \emph{computational task} takes an input bit string and produces an output bit string.

A decision problem is a computational task that produces an output of length 1.
Let \( B = B_1 = \qty{0,1} \) and denote \( B_n = \qty{0,1}^n \).
Define \( B^\star = \bigcup_{n \geq 1} B_n \).
A \emph{language} is a subset \( L \subseteq B^\star \).
A decision problem corresponds to the problem of checking whether a word \( w \in B^\star \) lies in a language \( L \).
For example, the set of primes, expressed in binary, forms a language \( P \subseteq B^\star \), and there is a corresponding decision problem to check if a given binary string represents a prime.

More generally, the output of a computational task can be of any length.
For example, the task \( \mathsf{FACTOR}(x) \) takes the input \( x \) and produces a bit string containing a factor of \( x \), or 1 if \( x \) is prime.

There are various models of computation, but we restrict to the \emph{circuit} model or \emph{gate array} model.
In this model, we have an input \( x = b_1 \dots b_n \in B_n \), and extend it with some trailing zeroes to add scratch space to perform computations.
We then perform a computational step, an application of designated Boolean gates \( f \colon B_n \to B_m \) on preassigned bits.
For each \( n \), we have a circuit \( C_n \), which is a prescribed sequence of computational steps that performs a given task for all inputs of size \( n \).
The output to the computation is a designated subsequence of the extended bit string.

Suppose that, in addition to extending the input bit string with zeroes, we also add \( k \) random bits, which have values set to 0 or 1 uniformly at random.
The output of the computation will now be probabilistic.
The probability that the output is \( y \) is \( a2^{-k} \), where \( a \) is the number of bit strings \( r \) that produce the desired outcome.
We typically require that the output is correct with some prescribed probability.

\subsection{Classical complexity}
The \emph{time complexity} is a measure of the amount of computational steps required for a particular algorithm for an input of size \( n \).
In the circuit model, we define \( T(n) \) to be the total number of gates in the circuit \( C_n \), known as the \emph{size} of the circuit or \emph{runtime} of the algorithm.

For a positive function \( T(n) \), we write \( T(n) = O(f(n)) \) if there exist positive constants \( c, n_0 \) such that for all \( n > n_0 \), we have \( T(n) \leq cf(n) \).
If \( T(n) = O(n^k) \) for some \( k > 0 \), we say that \( T(n) \) is \( O(\mathrm{poly}(n)) \), and the corresponding algorithm is a \emph{poly-time} algorithm.
The class of languages for which the membership problem has a classical poly-time algorithm is called \( \mathsf{P} \).
The class of languages for which the membership problem has a randomised classical poly-time algorithm that gives the correct answer with probability at least \( \frac{2}{3} \) is called \( \mathsf{BPP} \), short for \emph{bounded-error probabilistic poly-time}.
The problem \( \mathsf{FACTOR}(M,N) \) which determined if there is a nontrivial factor of \( N \) that is at most \( M \) does not lie in \( \mathsf{BPP} \).
The best known runtime is \( T(n) = O\qty(n^{\frac{1}{3}}\qty(\log n)^\frac{2}{3}) \).

A black box promise problem is a computational task where the input is a \emph{black box} or \emph{oracle} which can compute a Boolean function \( f \colon B_m \to B_n \), and there is an \emph{a priori promise} on \( f \) restricting the possible values of \( f \).
For example, the black box promise problem for constant vs.\ balanced functions takes a function \( f \colon B_n \to B \) such that \( f \) is constant or \emph{balanced}, in which case \( f \) is equal to zero for exactly half of the \( 2^n \) possible inputs.

The corresponding complexity is called \emph{query complexity}, which counts the amount of times we need to query the black box.
We typically wish to minimise the query complexity.

\subsection{Quantum circuits}
In a quantum circuit, we have qubit inputs \( \ket{b_1} \dots \ket{b_n} \ket{0} \dots \ket{0} \) analogously to the classical case.
The input size \( n \) is the number of qubits.
The addition of randomness to classical computation needs no analogue in the quantum case, since randomness is obtained by measurement.
For instance, if we have a qubit \( \ket{0} \), we can generate a uniform Bernoulli random variable by sending the qubit through a Hadamard gate and then measuring in the computational basis.

The computational steps are gates or unitary operators, which act on a prescribed set of qubits, which constitute a quantum circuit \( C_n \).
The output is obtained by performing a measurement on a prescribed set of qubits.
One can show that any circuit involving arbitrarily many measurements is equivalent to a circuit that only performs a single measurement at the end of the computation.

\subsection{Quantum oracles}
Note that all quantum gates are invertible, as they are represented with unitary operators, but not all classical gates are invertible.
Any \( f \colon B_m \to B_n \) can be expressed in an equivalent invertible form \( \widetilde f \colon B_{m+n} \to B_{m+n} \) by defining \( \widetilde f(b,c) = (b, c \oplus f(b)) \).
If we can compute \( f \) we can also compute \( \widetilde f \), and conversely given \( \widetilde f \) we can find \( f(b) = \widetilde f(b.0) \).
This is self-inverse.
\[ \widetilde f(\widetilde f(b,c)) = \widetilde f(b, c \oplus f(b)) = (b, c \oplus f(b) \oplus f(b)) = (b, c) \]
A quantum oracle for a function \( f \colon B_m \to B_n \) is the quantum gate \( U_f \) acting on \( m + n \) qubits such that \( U_f \ket{x} \ket{y} = \ket{x} \ket{y \oplus f(x)} \) for \( \ket{x}, \ket{y} \) states in the computational basis.
In other words, its action on the computational basis is \( \widetilde f \).
We say that \( \ket{x} \) is the \emph{input register} and \( \ket{y} \) is the \emph{output register}.

One can show that \( U_f \) is always a unitary operator.
We can show this directly by considering \( U_f \ket{x'}\ket{y'} = \ket{x'}\ket{y' \oplus f(x')} \), and we can take the inner product with \( U_f \ket{x} \ket{y} = \ket{x} \ket{y \oplus f(x)} \).
An easier way to show this is to consider \( \widetilde f \colon B_k \to B_k \) as a permutation on \( B_k \) where \( m + n = k \).
We can write \( U_f \ket{x} \ket{y} = U_f \ket{i_1 \dots i_k} = \ket{\widetilde f(i_1 \dots i_k)} \).
Since \( \widetilde f \) is a permutation, \( U_f \) is therefore represented by a permutation matrix, which has a single 1 in each row and column.
All permutation matrices are unitary.

In contrast to a classical oracle, a quantum oracle can act on a superposition of input registers.
Let \( f \colon B_m \to B_n \), and consider the \emph{equal superposition} state \( \ket{\varphi_m} = \frac{1}{\sqrt{2^m}} \sum_{x \in B_m} \ket{x} \).
We can find
\[ U_f \ket{\varphi_m} \ket{y} = U_f \qty( \frac{1}{\sqrt{2^m}} \sum_{x \in B_m} \ket{x}) \ket{y} = \frac{1}{\sqrt{2^m}} \sum_{x \in B_m} U_f \ket{x} \ket{y} = \ket{\psi_f} \]
In a single use of the oracle, we obtain a final state which depends on the value of \( f \) corresponding to all possible inputs.
One can easily create such an equal superposition state \( \ket{\varphi_m} \) by sending the \( m \)-qubit state \( \ket{0} \dots \ket{0} \) through \( m \) Hadamard gates \( H \otimes \dots \otimes H \).
We have \( \qty(H \ket{0})^{\otimes m} = \qty(\ket{+})^{\otimes m} = \ket{\varphi_m} \).
This creates a superposition of exponentially many terms using a linear amount of Hadamard gates.

\subsection{Deutsch--Jozsa algorithm}
Consider the black box problem for balanced vs.\ constant functions.
Classically, one needs \( 2^{n-1} + 1 \) queries to solve the problem in the worst case.
This amount of queries is clearly sufficient; even if \( f \) is balanced, the first \( 2^{n-1} \) queries could have equal outcomes, but the subsequent query must have a different outcome.
Suppose that there exists an algorithm that can solve the problem in \( 2^{n-1} \) queries.
An adversary that controls the oracle can respond with 0 for every query, and subsequently chooses a function \( f \) that agrees with the earlier query results but is balanced or constant as required to cause the algorithm to produce an error.
Therefore, classically we require a query complexity of \( O(\exp(n)) \).

Suppose we have a quantum oracle \( U_f \) with \( U_f \ket{x} \ket{y} = \ket{x} \ket{y \oplus f(x)} \), where \( \ket{x} \) is an \( n \)-qubit state and \( \ket{y} \) is a 1-qubit state.
Set each qubit to state \( \ket{0} \), then act by \( H^{\otimes n} \otimes (H \cdot X) \) on \( \ket{x} \ket{y} \).
We then obtain the state \( \ket{A} = \frac{1}{\sqrt{2^n}} \sum_{x \in B_n} \ket{x} \ket{-} \).
Send this state through the oracle to obtain \( U_f \ket{A} = \frac{1}{\sqrt{2^n}} U_f \sum_{x \in B_n} \ket{x} \ket{-} \).
Note that
\begin{align*}
    U_f \ket{x} \ket{-} &= \frac{1}{\sqrt{2}} U_f \qty(\ket{x}\ket{0} - \ket{x}\ket{1}) \\
    &= \frac{1}{\sqrt{2}} \qty(\ket{x}\ket{f(x)} - \ket{x}\ket{f(x)^c}) \\
    &= \begin{cases}
        \frac{1}{\sqrt{2}}\ket{x}(\ket{0} - \ket{1}) = \ket{x}\ket{-} & \text{if } f(x) = 0 \\
        \frac{1}{\sqrt{2}}\ket{x}(\ket{1} - \ket{0}) = -\ket{x}\ket{-} & \text{if } f(x) = 1
    \end{cases} \\
    &= (-1)^{f(x)} \ket{x}\ket{-}
\end{align*}
The method of encoding all information into a phase is called \emph{phase kickback}.
Hence,
\[ U_f \ket{A} = \frac{1}{\sqrt{2^n}} U_f \sum_{x \in B_n} \ket{x} \ket{-} = \frac{1}{\sqrt{2^n}} \qty(\sum_{x \in B_n} (-1)^{f(x)} \ket{x}) \ket{-} \]
We can then easily discard the last qubit, as it is now in a product state.
We obtain
\[ \ket{f} = \frac{1}{\sqrt{2^n}} \sum_{x \in B_n} (-1)^{f(x)} \ket{x} \]
If \( f \) is constant,
\[ \ket{f} = \pm \frac{1}{\sqrt{2^n}} \sum_{x \in B_n} \ket{x} = \pm \qty(H \ket{0})^{\otimes n} \]
If we apply \( H^{\otimes n} \) to \( \ket{f} \), we obtain \( \pm \ket{0}^{\otimes n} \).
If \( f \) is balanced, writing \( \ket{\varphi_n} = \frac{1}{\sqrt{2^n}} \sum_{y \in B_n} \ket{y} \),
\[ \ip{f}{\varphi_n} = \frac{1}{2^n} \sum_{x, y \in B_n} (-1)^{f(x)} \ip{y}{x} = \frac{1}{2^n} \sum_{x \in B_n} (-1)^{f(x)} = 0 \]
In this case, \( \ket{f} \) is orthogonal to \( \ket{\varphi_n} \).
Applying \( H^{\otimes n} \) to \( \ket{f} \), \( H^{\otimes n} \ket{f} \) is orthogonal to \( H^{\otimes n} \ket{\varphi_n} = \ket{0}^{\otimes n} \).

After obtaining \( \ket{f} \), we apply \( H^{\otimes n} \) and measure in the computational basis.
If \( f \) is constant, we measure \( 0\dots 0 \) with probability 1, and if \( f \) is balanced, we measure \( 0\dots 0 \) with probability 0.
This allows us to infer whether \( f \) is constant or balanced with probability 1.
\begin{center}
    \leavevmode
    \Qcircuit{
        \lstick{\ket{0}_1} & \qw & \gate{H} \qw & \multigate{4}{U_f} & \gate{H} & \meter \qw & \rstick{x_1} \cw \\
        \lstick{\ket{0}_2} & \qw & \gate{H} \qw & \ghost{U_f} & \gate{H} & \meter \qw & \rstick{x_2} \cw \\
        \vdots & & & & & & \vdots \\
        \lstick{\ket{0}_n} & \qw & \gate{H} \qw & \ghost{U_f} & \gate{H} & \meter \qw & \rstick{x_n} \cw \\
        \lstick{\ket{0}} & \gate{X} \qw & \gate{H} \qw & \ghost{U_f} & \rstick{\text{discard}} \qw
    }
\end{center}
For this algorithm, we use one query and \( 3n+2 \) further operations.

Suppose we permit a probability \( \varepsilon > 0 \) of error.
In the quantum case, we only need one query.
In the classical case, there is a randomised algorithm which solves the problem with a constant number \( O\qty(\log \frac{1}{\varepsilon}) \) of queries for all \( n \).
Choose \( k \) inputs each chosen uniformly at random, and evaluate \( f(x) \) for each \( x \) in this set.
If \( f(x) \) is constant for all of these \( k \) inputs, we infer \( f \) is constant; otherwise we infer it is balanced.
An error can only occur when the function is balanced but we infer it is constant.
The probability of error is \( \frac{2}{2^k} = 2^{-k+1} \).
Hence, we can take \( \varepsilon < 2^{-k+1} \), so \( k = O\qty(\log \frac{1}{\varepsilon}) \).

\subsection{Simon's algorithm}
Consider a function \( f \colon B_n \to B_n \) with the promise that either \( f \) is injective, or \( f(x) = f(y) \) if and only if \( y = x \) or \( y = x \oplus \xi \) for a fixed \( 0 \neq \xi \in B_n \).
The problem is to determine with bounded error whether \( f \) is in the 1-1 form or the 2-1 form, and in the latter case, to find the constant \( \xi \).
Note that \( f(x \oplus \xi) = f(x) \) is the statement that \( f \) has period \( \xi \).

Classically, the query complexity is \( O(\exp(n)) \).
In order to solve the problem, we need to find two distinct \( x, y \) inputs for which \( f(x) = f(y) \), or show that this is not possible.
However, there is a quantum algorithm with query complexity \( O(n) \).

\subsection{Quantum Fourier transform}
Let \( \mathcal V_N \) be a state space, and \( \mathcal B_N = \qty{\ket{0}, \ket{1}, \dots, \ket{N-1}} \) be an orthonormal basis for \( \mathcal V_N \).
Write \( \mathbb Z_N \) for integers modulo \( N \), and let \( \omega = e^{\frac{2\pi i}{N}} \).
For \( \ket{k} \in \mathcal B_N \), we define
\[ QFT_N\ket{k} = \frac{1}{\sqrt{N}} \sum_{\ell=0}^{N-1} e^{\frac{2\pi i}{N}k\ell} \ket{\ell} = \frac{1}{\sqrt{N}} \sum_{\ell=0}^{N-1} \omega^{k\ell} \ket{\ell} \]
The quantum Fourier transform can be viewed as a generalisation of the Hadamard operator, as \( QFT_2 = H \).

We show that this is a unitary operator.
\[ (QFT)_{jk} = \bra{j}QFT\ket{k} = \frac{1}{\sqrt{N}} \sum_{\ell=0}^{N-1} \omega^{k\ell} \ip{j}{\ell} = \frac{1}{\sqrt{N}} \omega^{jk} \]
\[ QFT = \frac{1}{\sqrt{N}} \begin{pmatrix}
    1 & 1 & 1 & 1 & \cdots \\
    1 & \omega & \omega^2 & \omega^3 & \cdots \\
    1 & \omega^2 & \omega^4 & \omega^6 & \cdots \\
    1 & \omega^3 & \omega^6 & \omega^9 & \cdots \\
    \vdots & \vdots & \vdots & \vdots & \ddots
\end{pmatrix} \]
Let \( S_j \) be the sum of the \( j \)th row or column.
If \( j = 0 \), \( S_j = \frac{1}{\sqrt{N}} N \).
Otherwise,
\[ S_j = \frac{1}{\sqrt{N}} (1 + \omega^j + \dots + \omega^{j(N-1)}) = \frac{1}{\sqrt{N}} \cdot \frac{1 - \omega^{jN}}{1 - \omega^j} = 0 \]
We can use this to prove that \( (QFT^\dagger QFT)_{jk} = \delta_{jk} \), so it is a unitary operator.

Suppose we have a periodic function \( f \colon \mathbb Z_N \to Y \), where typically \( Y = \mathbb Z_M \) for some \( M \).
Let \( r \) be the smallest integer in \( \mathbb Z_N \) for which \( f(x+r) = f(x) \) for all \( x \in \mathbb Z_N \), so \( f \) is periodic with period \( r \).
Suppose further that \( f \) is injective in each period.
We wish to find \( r \) with a particular probability of error.

There is a classical algorithm with query complexity \( O(\sqrt{N}) = O\qty(2^{\log N^{\frac{1}{2}}}) = O\qty(2^{\frac{1}{2} \log N}) \).
In the quantum case, for any error probability \( \varepsilon \in (0,1) \), there is an algorithm with query complexity \( O(\log \log N) \), which provides an exponential speed increase.

We first describe an attempt to construct such an algorithm without using the quantum Fourier transform.
Begin with the uniform superposition state \( \ket{\psi_N} = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} \ket{x} \).
Consider the quantum oracle \( U_f \) corresponding to \( f \colon \mathbb Z_N \to \mathbb Z_M \), defined by \( U_f \ket{x} \ket{y} = \ket{x} \ket{y + f(x)} \), where addition is performed modulo \( M \).
Set the output register \( \ket{y} \) to \( \ket{0} \), and then compute \( \ket{f} = U_f \ket{\psi_N} \ket{0} \).
We obtain
\[ \ket{f} = U_f \ket{\psi_N} \ket{0} = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} U_f \ket{x} \ket{0} = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} \ket{x} \ket{f(x)} \]
Since \( r \) is the period, we have \( r \mid N \), so let \( A = \frac{N}{r} \in \mathbb N \) be the number of periods.
We now measure the second register, giving an outcome \( y = f(x_0) \) for some \( x_0 \in \qty{0, \dots, r-1} \).
Note that \( y = f(x_0 + jr) \) for any \( j \in \qty{0, \dots, A-1} \).
The terms in \( \ket{f} \) which contribute to the outcome \( y = f(x_0) \) are
\[ \frac{1}{\sqrt{N}} \sum_{j=0}^{A-1} \ket{x_0 + jr} \ket{f(x_0)} \]
Hence, the probability of obtaining a particular outcome \( f(x_0) \) is \( \frac{A}{N} = \frac{1}{r} \).
The post-measurement state of the input register is
\[ \ket{\text{per}} = \frac{1}{\sqrt{A}} \sum_{j=0}^{A-1} \ket{x_0 + jr} \]
The state \( \ket{\text{per}} \) is periodic.
If we measure the input register, we obtain \( \ket{x_0 + j_0 r} \) for some \( j_0 \in \qty{0, \dots, A-1} \), selected uniformly at random.
The probability that the outcome of this second measurement is \( x_0 + j_0 r \) is \( \frac{1}{A} \).
Therefore, no information about \( r \) is obtained.

We resolve this issue by utilising the quantum Fourier transform.
Instead of measuring the input register, we act on \( \ket{\text{per}} \) by \( QFT_N \).
Since
\[ QFT_N\ket{x} = \frac{1}{\sqrt{N}}\sum_{y=0}^{N-1}\omega^{xy} \ket{y} \]
we find
\begin{align*}
    QFT_N \ket{\text{per}} &= \frac{1}{\sqrt{A}}\sum_{y=0}^{N-1} QFT_N \ket{x_0 + jr} \\
    &= \frac{1}{\sqrt{A}} \frac{1}{\sqrt{N}} \sum_{j=0}^{A-1} \sum_{y=0}^{N-1} \omega^{(x_0 + jr)y} \ket{y} \\
    &= \frac{1}{\sqrt{NA}} \sum_{y=0}^{N-1} \omega^{x_0 y} \underbrace{\qty[\sum_{j=0}^{A-1} \qty(\omega^{ry})^j]}_S \ket{y}
\end{align*}
Note that
\[ S = \begin{cases}
    A & \text{if } \omega^{ry} = 1 \\
    \frac{1 - \omega^{ryA}}{1 - \omega^{ry}} = 0 & \text{otherwise}
\end{cases} \]
Note that \( \omega^{ry} = 1 \) if \( y = kA = \frac{kN}{r} \) for \( k \in \qty{0, \dots, r - 1} \).
Hence, we obtain
\[ QFT_N \ket{\text{per}} = \frac{A}{\sqrt{NA}} \sum_{k=0}^{r-1} \omega^{x_0 \frac{kN}{r}} \ket{\frac{kN}{r}} = \frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} \omega^{x_0 \frac{kN}{r}} \ket{\frac{kN}{r}} \]
The value of \( x_0 \) is no longer present in a ket, and has been converted into phase information.
It therefore does not affect measurement outcomes.
The periodicity in \( r \) has been inverted into periodicity in \( \frac{1}{r} \).
The resulting state is still periodic, but each period begins at 0 instead of \( x_0 \).

Now, when measuring this register, the outcome is \( c = \frac{k_0N}{r} \) for some \( k_0 \in \qty{0, \dots, r-1} \).
Each outcome occurs with probability \( r \).
Note that \( \frac{k_0}{r} = \frac{c}{N} \), and \( \frac{c}{N} \) is known after performing the measurement; we wish to know the value of \( r \).

Suppose first that \( k_0 \) is coprime to \( r \).
In this case, we can cancel \( \frac{c}{N} \) to its lowest form, then the denominator is \( r \).
If \( k_0 \) is not coprime to \( r \), the denominator \( \widetilde r \) will instead be a factor of \( r \).
To solve this, we can compute the reduced denominator and then evaluate \( f(0), f(\widetilde r) \); if they are equal, \( \widetilde r = r \), and otherwise, \( \widetilde r \mid r \).
We would like to know the probability that a randomly chosen \( k_0 \) is coprime to the true periodicity \( r \).
\begin{theorem}[coprimality theorem]
    Let \( \varphi(r) \) denote the number of integers less than \( r \) that are coprime to \( r \).
    Then there exist \( c > 0, r_0 > 0 \) such that for all \( r \geq r_0 \), \( \varphi(r) \geq c \frac{r}{\log \log r} \).
    In particular, \( \varphi(r) = \Omega\qty(\frac{r}{\log \log r}) \).
\end{theorem}
This theorem implies that since \( k_0 \) is chosen uniformly at random, the probability that \( k_0 \) is coprime to \( r \) is \( O\qty(\frac{1}{\log \log r}) \).
We claim that if we repeat this process \( O(\log \log r) \) times, we will obtain an outcome \( c \) such that after cancellation, \( \frac{c}{N} = \frac{k_0}{r} \) where \( k_0 \) is coprime to \( r \) in at least one case, with a constant probability.
This claim follows from the following lemma.
\begin{lemma}
    Suppose that a single trial has success probability \( p \), and the trial is repeated \( M \) times independently, for any \( \varepsilon \in (0,1) \), the probability of at least one success is greater than \( 1 - \varepsilon \) if \( M = \frac{-\log \varepsilon}{p} \).
\end{lemma}
Therefore, to achieve a constant probability \( 1 - \varepsilon \) of success, we need \( O\qty(\frac{1}{p}) \) trials.
In the algorithm above, \( p = O\qty(\frac{1}{\log \log r}) \), so we need \( O(p) = O(\log \log r) < O(\log \log N) \) trials to achieve the desired result.

In each invocation of the algorithm, we query \( f \) three times: once to construct the state \( \ket{f} \), and twice to check if \( \widetilde r \) is the true periodicity.
We also need to apply the quantum Fourier transform \( QFT_N \), which has implementations in \( O((\log N)^2) \) steps.
We must also perform standard arithmetic operations such as to cancel denominators, which are computable in \( O(\mathrm{poly}(\log N)) \) steps.
Therefore, we succeed in determining the period with any constant probability of success \( 1 - \varepsilon \) with \( O(\log \log N) \) queries and \( O(\mathrm{poly}(\log N)) \) additional steps.

\subsection{Efficient implementation of quantum Fourier transform}
We can implement a quantum Fourier transform using \( O(\mathrm{poly}(\log N)) \) gates if \( N = 2^n \).
In this case, \( QFT_N \) acts on \( n \) qubits.
If \( N \neq 2^n \), we do not have an efficient implementation; in this case, we approximate \( N \) by \( 2^k \) for some \( k \in \mathbb Z \).
In the case \( N = 2^n \), we demonstrate a quantum circuit of size \( O(n^2) \).

If \( x \in \mathbb Z_n = \qty{0, \dots, 2^n - 1} \), note that
\[ QFT_N \ket{x} = \frac{1}{\sqrt{N}} \sum_{y=0}^{N-1} \omega^{xy} \ket{y} \]
We can represent \( x \) and \( y \) by \( n \)-bit strings.
\[ x = (x_0, x_1, \dots, x_{n-1});\quad x = \sum_{i=0}^{n-1} 2^i x_i \]
Now, \( \omega^{xy} = \exp\qty[\frac{2\pi i}{2^n} xy] \).
\[ \frac{xy}{2^n} = \frac{1}{2^n} \qty[(x_0 + 2x_1 + \dots + 2^{n-1} x_{n-1})(y_0 + 2y_1 + \dots + 2^{n-1} y_{n-1})] \]
Retaining only the fractional terms of \( \frac{xy}{2^n} \), as integral parts do not contribute to the final result, we obtain
\[ y_{n-1}(.x_0) + y_{n-2}(.x_1 x_0) + \dots + y_0(.x_{n-1} \dots x_0) \]
where for instance \( .x_1 x_0 = \frac{x_1}{2} + \frac{x_0}{2^2} \).
Hence,
\begin{align*}
    QFT \ket{x} &= \frac{1}{\sqrt{2^n}} \sum_{y_0, \dots, y_{n-1} \in \qty{0,1}} \exp\qty[\frac{2\pi i xy}{2^n}] \ket{y_{n-1}} \dots \ket{y_0} \\
    &= \qty(\frac{1}{\sqrt{2}} \sum_{y_{n-1} \in \qty{0,1}} \exp\qty[2 \pi i y_{n-1} (.x_0)] \ket{y_{n-1}}) \cdots \qty(\frac{1}{\sqrt{2}} \sum_{y_0 \in \qty{0,1}} \exp\qty[2 \pi i y_0 (.x_{n-1}\dots x_0)] \ket{y_0}) \\
    &= \frac{1}{\sqrt{2}} \qty(\ket{0} + e^{2\pi i (.x_0)} \ket{1}) \dots \frac{1}{\sqrt{2}} \qty(\ket{0} + e^{2\pi i (.x_{n-1} \dots x_0)} \ket{1})
\end{align*}
To implement the quantum Fourier transform, we will use the Hadamard gate, the 1-qubit phase gate, and the 2-qubit controlled phase gate.
Note that we can write
\[ H\ket{x} = \frac{1}{\sqrt{2}} \qty[\ket{0} + e^{2\pi i(.x)} \ket{1}] \]
For any \( d \in \mathbb Z_+ \), the phase gate is given by
\[ R_d = \begin{pmatrix}
    1 & 0 \\
    0 & \exp[\frac{i\pi}{2^d}]
\end{pmatrix} = \begin{pmatrix}
    1 & 0 \\
    0 & \exp[2\pi i(.\underbrace{0\dots 0}_{\mathclap{d \text{ zeroes}}}1)]
\end{pmatrix} \]
Note that \( R_d \ket{0} = \ket{0} \) and \( R_d \ket{1} = e^{2\pi i(.0\dots 01)} \ket{1} \).
In the case \( d = 1 \), we obtain \( R_1 \ket{1} = e^{2 \pi i(.01)} \ket{1} = i \ket{1} \).
The two-qubit controlled phase gate, denoted \( CR_d \), is drawn
\begin{center}
    \leavevmode
    \Qcircuit{
        \lstick{\ket{\psi}} & \gate{R_d} & \qw \\
        \lstick{\ket{\varphi}} & \ctrl{-1} & \qw
    }
\end{center}
If \( \ket{\varphi} = \ket{0} \), \( CR_d\ket{0}\ket{\psi} = \ket{0}\ket{\psi} \).
If \( \ket{\varphi} = \ket{1} \), \( CR_d\ket{1}\ket{\psi} = \ket{1}R_d\ket{\psi} \).
We will now describe the quantum circuit for \( QFT_8 \), so \( N = 8 \) and \( n = 3 \).
\begin{center}
    \leavevmode
    \Qcircuit{
        \lstick{\ket{x_2}} & \gate{H} & \gate{R_1} & \gate{R_2} & \qw & \qw & \qw & \rstick{\ket{y_0}} \qw \\
        \lstick{\ket{x_1}} & \qw & \ctrl{-1} & \qw & \gate{H} & \gate{R_1} & \qw & \rstick{\ket{y_1}} \qw \\
        \lstick{\ket{x_0}} & \qw & \qw & \ctrl{-2} & \qw & \ctrl{-1} & \gate{H} & \rstick{\ket{y_2}} \qw
    }
\end{center}
Applying the given gates to \( \ket{x_2} \), we obtain
\begin{align*}
    \ket{x_2} &\xrightarrow{H} \frac{1}{\sqrt{2}}\qty[\ket{0} + e^{2\pi i (.x_2)} \ket{1}] \\
    &\xrightarrow{R_1} \frac{1}{\sqrt{2}}\qty[\ket{0} + e^{2\pi i (.x_2)} e^{2\pi i(.0x_1)} \ket{1}] \\
    &\xrightarrow{R_2} \frac{1}{\sqrt{2}}\qty[\ket{0} + e^{2\pi i(.x_2)} e^{2\pi i(.0x_1)} e^{2\pi i(.00x_0)} \ket{1}] \\
    &= \frac{1}{\sqrt{2}}\qty[\ket{0} + e^{2\pi i(.x_2 x_1 x_0)} \ket{1}] = \ket{y_0}
\end{align*}
as required.
Typically, after applying the above circuit, we will swap the states \( \ket{y_0}, ket{y_1}, \ket{y_2} \) to be in reverse order; this takes \( O(n) \) gates.

In this implementation, we used 3 Hadamard gates, and \( 2 + 1 = 3 \) controlled phase gates.
If \( N = 2^n \), we need \( n \) Hadamard gates and \( \frac{n(n-1)}{2} = O(n^2) \) controlled phase gates.

\subsection{Grover's algorithm}
Suppose we have a large unstructured database of \( N \) items, in which we aim to locate a particular `good' item.
Suppose that given an item, we can easily check if it is the `good' item.
We wish to construct an algorithm to locate this good item with success probability at least \( 1 - \varepsilon \).
Each access to the database is called a query.

In the classical case, we need \( O(N) \) queries: if we find a bad item, it gives us no information about the location of the good item.
The probability that any item is good is \( \frac{1}{N} \).
Given \( M \) queries, the probability of success is \( \frac{M}{N} \geq 1 - \varepsilon \), so \( M \geq (1-\varepsilon)N \) gives \( M = O(N) \).
In the quantum case, \( O(\sqrt{N}) \) queries are necessary and sufficient.
This is not an exponential speedup but a quadratic speedup.

Let \( \mathcal V \) be a vector space, and let \( \ket{v} \in \mathcal V \).
We define the rank 1 projection operator \( \Pi_{\ket{\alpha}} = \op{\alpha}{\alpha} \), and the reflection operator \( I_{\ket{\alpha}} = I - 2 \op{\alpha}{\alpha} \).
Note that \( I_{\ket{\alpha}} \ket{\alpha} = - \ket{\alpha} \).
Let \( \ket{\psi} \in \mathcal S_{\ket{v}}^\perp = \vecspan\qty{\ket{\beta} \in \mathcal V \mid \ip{\alpha}{\beta} = 0} \) .
Then \( I_{\ket{\alpha}} \ket{\psi} = \ket{\psi} - \ket{\alpha}\ip{\alpha}{\psi} = \ket{\psi} \).

For any unitary operator \( U \) acting on \( \mathcal V \), we have \( U \Pi_{\ket{\alpha}} U^\dagger = U \op{\alpha}{\alpha} U^\dagger = \Pi_{U\ket{\alpha}} \).
Note also that \( U I_{\ket{\alpha}} U^\dagger = U(I - 2 \op{\alpha}{\alpha}) U^\dagger = I - 2 \op{U\alpha}{U\alpha} = I_{U\ket{\alpha}} \).

If \( \mathcal V \in \mathbb C^2 \), for all \( \ket{\alpha} \in \mathcal V \), let \( \ket{\alpha^\perp} \) be orthogonal to \( \ket{\alpha} \).
For all \( \ket{v} \in \mathcal V \), we can write \( \ket{v} = a \ket{\alpha} + b \ket{\alpha^\perp} \), so \( \Pi_{\ket{\alpha}} \ket{v} = a \ket{\alpha} \) and \( I_{\ket{\alpha}} \ket{v} = -a\ket{\alpha} + b \ket{\alpha^\perp} \).

Let \( N = 2^n \), so we can label each item in the database with an \( n \)-bit binary string.
We will convert the search problem into a black-box promise problem.
The database corresponds to the Boolean function \( f \colon B_n \to B \) where \( f(x_0) = 1 \) for a particular \( x_0 \in B_n \), and \( f(x) = 0 \) otherwise.
The corresponding quantum oracle is \( U_f \ket{x} \ket{y} = \ket{x} \ket{y \oplus f(x)} \), where \( \ket{x} \in (\mathbb C^2)^{\otimes n} \) and \( \ket{y} \in \mathbb C^2 \).
The fact that the databse is unstructured corresponds to the fact that the quantum oracle \( U_f \) is a black box.
We will actually use the operator \( I_{x_0} \).
\[ I_{x_0} \ket{x} = \begin{cases}
    +\ket{x} & \text{if } x \neq x_0 \\
    -\ket{x} & \text{if } x = x_0
\end{cases} \]
If \( x_0 = 0\dots 0 \in B_n \), we define \( I_0 = I_{x_0} \).
Note that \( I_{x_0} \) can be implemented using \( U_f \); indeed,
\begin{align*}
    U_f \ket{x} \ket{-} &= \frac{1}{\sqrt{2}} U_f \ket{x} \qty(\ket{0} - \ket{1}) \\
    &= \frac{1}{\sqrt{2}}\qty(\ket{x} \ket{f(x)} - \ket{x} \ket{f(x)^c}) \\
    &= \begin{cases}
        \frac{1}{\sqrt{2}} \ket{x} \qty(\ket{0} - \ket{1}) & \text{if } x \neq x_0 \\
        \frac{1}{\sqrt{2}} \ket{x} \qty(\ket{1} - \ket{0}) & \text{if } x = x_0
    \end{cases} \\
    &= \begin{cases}
        +\ket{x}\ket{-} & \text{if } x \neq x_0 \\
        -\ket{x}\ket{-} & \text{if } x = x_0
    \end{cases}
\end{align*}
Hence, \( U_f \ket{x} \ket{-} = (I_{x_0} \ket{x})\ket{-} \).
So if \( \ket{\psi} \in (\mathbb C^2)^{\otimes n} \), \( \ket{\psi} = a_0 \ket{x_0} + \sum_{x \neq x_0} a_x \ket{x} \) gives \( U_f \ket{\psi}\ket{-} = (I_{x_0} \ket{\psi}) \ket{-} = -a_0 \ket{x_0} + \sum_{x \neq x_0} a_x \ket{x} \).

Given a black box which computes \( I_{x_0} \) for some \( x_0 \in B_n \), we wish to determine \( x_0 \) with the least amount of queries.
We will now describe Grover's algorithm.
We begin with the equal superposition state \( \ket{\psi_0} = \frac{1}{\sqrt{2^n}} \sum_{x \in B_n} \ket{x} \).
Consider \emph{Grover's iteration operator} \( Q = -H_n I_0 H_n I_{x_0} \) where \( H_n = H^{\otimes n} \).
Note that \( Q \) is real-valued, so acts geometrically on the real-valued vector \( \ket{\psi_0} \) in real Euclidean space.
It has the following properties.
\begin{enumerate}
    \item In the plane \( \mathcal P(x_0) \) spanned by \( \ket{x_0} \) and \( \ket{\psi_0} \), \( Q \) acts as a rotation through an angle \( 2\alpha \) where \( \sin \alpha = \frac{1}{\sqrt{2^n}} \).
    \item In the plane orthogonal to \( \mathcal P(x_0) \), \( Q \) acts as \( -I \).
\end{enumerate}
We repeatedly apply \( Q \) to \( \ket{\psi_0} \) to obtain the rotated vector \( \ket{\psi_0'}\), and then measure in the computational basis.
\[ \ket{\psi_0'} = a_0 \ket{x_0} + \sum_{x_i \neq x_0} \sum a_i \ket{x_i} \]
Hence, the probability that the outcome is \( x_0 \) is \( \abs{a_0}^2 = \abs{\ip{x_0}{\psi_0'}}^2 = \abs{\cos \delta}^2 \approx 1 \) where \( \delta \) is the angle between \( \ket{\psi_0'} \) and \( \ket{x_0} \).

If \( n \) is large, \( \ket{\psi_0} \) is almost orthogonal to \( \ket{x_0} \), with \( \ip{x_0}{\psi_0} = \frac{1}{\sqrt{2^n}} = \cos \beta \).
By property (i), \( Q \) acting on \( \ket{\psi_0} \) rotates the state by \( 2\alpha \), where \( \sin\alpha = \frac{1}{\sqrt{2^n}} \).
Let \( m \) be the number of iterations needed to rotate \( \ket{\psi_0} \) close to \( \ket{x_0} \).
Then
\[ m = \frac{\beta}{2\alpha} = \frac{\arccos\qty(\frac{1}{\sqrt{2^n}})}{2\arcsin\qty(\frac{1}{\sqrt{2^n}})} \]
Since \( \sin \alpha \approx \alpha \), this implies that \( 2\alpha \approx 2\sin\alpha = \frac{2}{\sqrt{2^n}} \).
Then \( 2 \alpha m \approx \frac{\pi}{2} \), so \( m \approx \frac{\pi}{4\alpha} = \frac{\pi}{4} \sqrt{N} \).
The number of iterations is independent of \( \ket{x_0} \); it depends only on \( n \).
\begin{example}
    Consider a database with four items, so \( n = 2, N = 4 \).
    Here, \( \sin \alpha = \frac{1}{2} \), so \( \alpha = \frac{\pi}{6} \).
    \( Q \) causes a rotation through \( 2\alpha = \frac{\pi}{3} \).
    The initial state is \( \ket{\psi_0} = \ket{++} = \frac{1}{2}\qty(\ket{00} + \ket{01} + \ket{10} + \ket{11}) \).
    For any \( x_0 \in B_2 \), we have \( \cos\beta = \ip{x_0}{\psi_0} = \frac{1}{2} \) so \( \beta = \frac{\pi}{3} \).
    Therefore, we need precisely one iteration, which rotates \( \ket{\psi_0} \) to \( \ket{x_0} \) exactly.
    Performing a measurement in the computational basis, we obtain \( x_0 \) with certainty.
\end{example}
We now prove the geometric properties of \( Q \).
First, note that \( Q = -H_n I_0 H_n I_{x_0} = -I_{\ket{\psi_0}} I_{\ket{x_0}} \).
If \( \ket{\alpha}, \ket{v} \in \mathcal V \) and \( \ket{v} \in \mathcal P(x_0) \), we have
\begin{itemize}
    \item \( I_{\ket{x_0}} \ket{v} = \ket{v} - 2\ip{x_0}{v} \ket{x_0} \);
    \item \( I_{\ket{\psi_0}} \ket{v} = \ket{v} - 2\ip{\psi_0}{v} \ket{\psi_0} \).
\end{itemize}
These operators are reflections about lines perpendicular to \( \ket{x_0} \) and \( \ket{\psi_0} \) respectively.
Thus, \( \mathcal P(x_0) \) is stable under the action of \( I_{\ket{x_0}} \) and \( I_{\ket{\psi_0}} \).

Let \( M_1, M_2 \) be lines in the Euclidean plane, intersecting at \( O \).
Let \( \theta \) be the angle between \( M_1 \) and \( M_2 \).
Then, reflection about \( M_1 \) then \( M_2 \) acts as an anticlockwise rotation by \( 2\theta \) about \( O \).

In our case, the angle between the lines perpendicular to \( \ket{x_0} \) and \( \ket{\psi_0} \) is \( \beta \).
Therefore, \( I_{\ket{\psi_0}} I_{\ket{x_0}} \) is an anticlockwise rotation by an angle of \( 2\beta \).
For any real unit vector \( v \in \mathbb R^2 \), we have \( -I_v = I_{v^\perp} \) where \( v_\perp \) is a unit vector orthogonal to \( v \).
Hence, \( -I_{\ket{\psi_0}} I_{\ket{x_0}} = I_{\ket{\psi_0^\perp}} I_{\ket{x_0}} \), which is an anticlockwise rotation by an angle of \( 2\alpha \), as \( \alpha + \beta = \frac{\pi}{2} \).
This proves property (i).

Now consider \( \ket{\xi} \in \mathcal P(x_0)^\perp \) perpendicular to \( \ket{\psi_0} \) and to \( \ket{x_0} \).
Clearly \( I_{\ket{x_0}} \ket{\xi} = \ket{\xi} \) and \( I_{\ket{\psi_0}} \ket{\xi} = \ket{\xi} \).
So \( Q \ket{\xi} = -\ket{\xi} \), giving property (ii).

Grover's algorithm achieves an unstructured search for a unique good item in approximately \( \frac{\pi}{4}\sqrt{N} \) queries, and there is no algorithm that has smaller asymptotic query complexity.
Any quantum algorithm that achieves this search in an unstructured database of size \( N \) must use \( O(\sqrt{N}) \) queries.
Moreover, it can be shown that \( \frac{\pi}{4} (1 - \varepsilon) \sqrt{N} \) queries are insufficient for each \( \varepsilon \), so Grover's algorithm is tight.

Consider the case where there are \( r \geq 1 \) good items.
Here, \( f(x_i) = 1 \) if \( i = 1, \dots, r \), and \( f(x) = 0 \) otherwise, where the \( x_i \) are the binary labels for the good items.
Then, define
\[ I_G \ket{x} = I - 2\sum_{i=1}^r \op{x_i}{x_i} = \begin{cases}
    +\ket{x} & x \not\in \qty{x_1, \dots, x_r} \\
    -\ket{x} & x \in \qty{x_1, \dots, x_r}
\end{cases} \]
Now, define \( Q_G = -H_n I_0 H_n I_G = -I_{\ket{\psi_0}} I_G \).
Let \( \ket{\psi_G} = \frac{1}{\sqrt{r}} \sum_{i=1}^r \ket{x_i} \) be an equal superposition of the good states, and \( \ket{\psi_B} = \frac{1}{\sqrt{N-r}} \sum_{i=1}^r \ket{x_i} \) be an equal superposition of the bad states.
