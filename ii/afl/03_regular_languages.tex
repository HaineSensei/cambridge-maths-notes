\subsection{Regular derivations}
\begin{definition}
	A rule of the form \( A \to a \) is called a \emph{terminal rule}.
	A rule of the form \( A \to aB \) is called a \emph{nonterminal rule}.
\end{definition}
\begin{lemma}
	Let \( G \) be a regular grammar.
	If \( S \xrightarrow G \alpha \), then \( \alpha \in \mathbb W \cup \mathbb W V \).
\end{lemma}
\begin{proof}
	This is shown by induction on the length of the derivation.
	The length-zero derivation gives \( \alpha = S = \varepsilon S \in \mathbb W V \).
	Suppose \( S \xrightarrow G \beta \xrightarrow G_1 \alpha \) where \( \beta \in \mathbb W \cup \mathbb W V \).
	If \( \beta \in \mathbb W \), \( \beta \) contains no variables, but all rules rewrite a variable.
	This contradicts that \( \beta \xrightarrow G_1 \alpha \).
	So suppose \( \beta = wA \) for \( w \in \mathbb W \), \( A \in V \).
	Then the rule must be of the form \( A \to a \) or \( A \to aB \).
	Hence \( \beta = wa \) or \( \beta = waB \).
	In either case, the required invariant holds.
\end{proof}
\begin{lemma}
	If \( S \xrightarrow G w \) for \( w \in \mathbb W \), then the derivation has length \( \abs{w} \) and consists of precisely \( \abs{w}-1 \) nonterminal rules and one final terminal rule.
\end{lemma}
\begin{proof}
	Terminal rules preserve the length of a string, and decrement the amount of variables.
	Nonterminal rules increment the length of a string, and preserve the amount of variables.
	Given that \( S \) is a string of length one with one variable, we must apply \( \abs{w}-1 \) nonterminal rules to increment the length of the string \( \abs{w}-1 \) times.
	By the previous lemma, the number of variables in each derived string is always 0 or 1.
	If the number ever reaches zero, nothing can be rewritten.
	Given \( w \in \mathbb W \), the number must reach zero, so a single terminal rule must be applied at the end.
\end{proof}
Note that the derivation is not uniquely determined.
\begin{lemma}
	Regular languages are closed under concatenation.
\end{lemma}
\begin{proof}
	Let \( G = (\Sigma, V, P, S), G' = (\Sigma, V', P', S') \), where without loss of generality \( V \cap V' = \varnothing \).
	Let \( P^\star \) be the set of production rules given by \( P \), but for each terminal rule \( A \to a \) in \( P \), replace it with a nonterminal rule \( A \to aS' \).
	Then let \( H = (\Sigma, V \cup V', P^\star \cup P', S) \).
	We claim \( \mathcal L(H) = \mathcal L(G)\mathcal L(G') \).

	Suppose \( S \xrightarrow G v \) and \( S' \xrightarrow {G'} w \).
	Then \( S \xrightarrow H vS' \), and so \( S \xrightarrow H vw \) as required.

	Conversely, suppose \( S \xrightarrow u \) for \( u \in \mathbb W \).
	By the above lemma, the derivation is of the form
	\[ S = \sigma_0 \xrightarrow H_1 \dots \xrightarrow H_1 \sigma_n = u \]
	where \( \sigma_i = w_i X_i \) for some \( w_i \in \mathbb W, X_i \in V \).
	An initial segment of the \( X_i \) belongs to \( V \), until rewritten as \( S' \) by a rule added into \( P^\star \).
	Then, the rest of the \( X_i \) belong to \( V' \), because only the new rules in \( P^\star \) map variables between \( V \) and \( V' \).
	Hence the derivation splits into two halves, \( u = vw \) where \( S \xrightarrow G v, S' \xrightarrow {G'} w \), giving the concatenation as required.
\end{proof}

\subsection{Deterministic automata}
\begin{definition}
	Let \( \Sigma \) be an alphabet.
	Then a \emph{deterministic automaton} is a tuple of the form \( D = (\Sigma, Q, \delta, q_0, F) \) where \( Q \) is a finite set of \emph{states}, \( q_0 \in Q \) is the \emph{start state}, \( F \subseteq Q \setminus \qty{q_0} \) is the \emph{accept states}, and \( \delta \colon Q \times \Sigma \to Q \) is the \emph{transition function}.
\end{definition}
We graphically represent deterministic automata using labelled directed graphs.
The nodes are elements of \( Q \), circled twice for accept states and circled once for other states.
Each node has \( \abs{\Sigma} \)-many outgoing arrows labelled with the corresponding letter.

\begin{center}
	\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
		\node[state, initial] (q_0) {\( q_0 \)};
		\node[state, accepting] (q_1) [above right=of q_0] {\( q_1 \)};
		\node[state] (q_2) [right=of q_0] {\( q_2 \)};

		\path[->]
			(q_0) edge node {0} (q_1)
			(q_0) edge node [swap] {1} (q_2)
			(q_2) edge node [swap] {0} (q_1)
			(q_2) edge [loop below] node {1} ()
			(q_1) edge [loop above] node {0, 1} ()
		;
	\end{tikzpicture}
\end{center}

We intuitively interpret a deterministic automaton as a machine that starts at \( q_0 \) and reads a word \( w \in \mathbb W \) symbol-by-symbol, transitioning to a new state according to \( \delta \) at each step.
After all symbols in the word are parsed, we check whether the machine lies in an accept state or not.
We say the automaton \emph{accepts} \( w \) if the final state is an accept state; otherwise, it \emph{rejects} \( w \).
\begin{definition}
	We define by recursion a function \( \hat\delta \colon Q \times \mathbb W \to Q \) by \( \hat\delta(q,\varepsilon) = q \) and \( \hat\delta(q,aw) = \hat\delta(\delta(q,a),w) \).
	The \emph{language accepted by \( D \)} is
	\[ \mathcal L(D) = \qty{w \mid \hat \delta(q_0, w) \in F} \]
	The sequence of states produced from \( q_0 \) and reading \( w \) is uniquely determined and of length \( \abs{w} + 1 \), known as the \emph{state sequence} of the computation.
\end{definition}
We claim that in the example above, \( \mathcal L(D) = \qty{w \mid w \text{ contains at least one } 0} \).
Note that \( \hat\delta(q_0,w) = q_0 \) if and only if \( w = \varepsilon \).
There are three transitions in the diagram for the letter 0, but all such 0-transitions lead to \( q_1 \) hence every string with a zero goes to \( q_1 \).
All transitions from \( q_1 \) go back to \( q_1 \), so any string containing a zero must end at \( q_1 \).
All other strings are of the form \( 1111\dots 1 \), which ends at \( q_2 \).
\begin{definition}
	Let \( D = (\Sigma, Q, \delta, q_0, F), D' = (\Sigma, Q', \delta', q_0', F') \) be deterministic automata.
	Then a map \( f \colon Q \to Q' \) is called a \emph{homomorphism} from \( D \) to \( D' \) if
	\begin{enumerate}
		\item for all \( q \in Q \) and \( a \in \Sigma \), we have \( \delta'(f(q),a) = f(\delta(q,a)) \);
		\item \( f(q_0) = q_0' \);
		\item \( q \in F \) if and only if \( f(q) \in F' \).
	\end{enumerate}
\end{definition}
In particular, if \( f \) is bijective, it has an inverse and is called an \emph{isomorphism}.
We can show by induction that \( \hat \delta'(f(q),w) = f(\hat\delta(q,w)) \).
Note that if a homomorphism \( f \) is not surjective, the states not in its range are not \emph{accessible} from \( q_0' \).
If \( f \) is not injective, so \( f(p) = f(q) \) for \( p \neq q \), then we have \( f(\hat\delta(p,w)) = \hat\delta'(f(p),w) = \hat\delta'(f(q),w) = f(\hat\delta(q,w)) \); we will say that such states \( p, q \) are \emph{indistinguishable}.
We will observe that failure to be bijective only affects inaccessible states or pairs of indistinguishable states.
\begin{proposition}
	Let \( f \) be a homomorphism (not \emph{a priori} an isomorphism) from \( D \) to \( D' \).
	Then \( \mathcal L(D) = \mathcal L(D') \).
\end{proposition}
\begin{proof}
	Let \( w \in \mathcal L(D) \), so \( \hat\delta(q_0,w) \in F \).
	Applying \( f \), \( f(\hat\delta(q_0,w)) = \hat\delta'(f(q_0),w) = \hat\delta'(q_0',w) \in F' \) as required.
	All implications are bi-implications, so the converse holds.
\end{proof}
\begin{theorem}
	Any language of the form \( \mathcal L(D) \) for a deterministic automaton \( D \) is regular.
\end{theorem}
\begin{proof}
	Let \( D = (\Sigma, Q, \delta, q_0, F) \), and define a grammar \( G = (\Sigma, V, P, S) \) by \( V = Q, S = q_0 \), and
	\[ P = \qty{p \to aq \mid \delta(p, a) = q} \cup \qty{p \to a \mid \delta(p,a) \in F} \]
	We will show \( \mathcal L(D) = \mathcal L(G) \).
	Suppose \( w = a_0\dots a_n \in \mathcal L(D) \).
	Then \( \hat \delta(q_0,w) \in F \), so there exist \( q_0, \dots, q_{n+1} \) such that \( q_{i+1} = \delta(q_i, a_i) \), and \( q_{n+1} \in F \).
	By definition of \( G \), this holds if and only if there exist \( q_0, \dots, q_{n+1} \) such that \( q_i \to a_i q_{i+1} \in P \) and \( q_n \to a_n \in P \).
	This holds if and only if there exists \( q_0, \dots, q_{n+1} \) such that \( q_0 \xrightarrow G_1 a_0 q_1 \xrightarrow G_1 \dots \xrightarrow G_1 a_0 \dots a_{n-1} q_n \xrightarrow G_1 w \), so there exists a derivation \( w \in \mathcal L(G) \).
	By regularity of \( G \), all derivations are of this form, so we have bi-implications, and \( \mathcal L(D) = \mathcal L(G) \).
\end{proof}
We will show that if \( L \) is a regular language, we can find a deterministic automaton \( D \) such that \( L = \mathcal L(D) \).
However, regular grammars can have multiple rules that may be used when reaching a single symbol, for instance \( p \to aq \) and \( p \to aq' \), so we cannot perform an obvious translation from this grammar into a deterministic automaton.
To encapsulate this notion, we introduce nondeterministic automata.

\subsection{Nondeterministic automata}
\begin{definition}
	A \emph{nondeterministic automaton} is a tuple of the form \( N = (\Sigma, Q, \delta, q_0, F) \) where \( Q \) is a finite set of states, \( q_0 \in Q \), \( F \in Q \setminus \qty{q_0} \), but in contrast with deterministic automata, we have \( \delta \colon Q \times \Sigma \to \mathcal P(Q) \).
\end{definition}
We interpret \( \delta(q,a) \) as the set of possible states that the machine can transition into when reading \( a \) from state \( q \).
The graphical representation of such an automaton is the same.

\begin{center}
	\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
		\node[state, initial] (q_0) {\( q_0 \)};
		\node[state, accepting] (q_1) [right of=q_0] {\( q_1 \)};
		\node[state] (q_2) [below=of q_1] {\( q_2 \)};

		\path[->]
			(q_0) edge node {\( a \)} (q_1)
			(q_0) edge node [swap] {\( a \)} (q_2)
			(q_1) edge [loop right] node {\( a \)} ()
			(q_1) edge node {\( a \)} (q_2)
			(q_2) edge [loop right] node {\( b \)} ()
		;
	\end{tikzpicture}
\end{center}
Here, we define \( \hat \delta \colon Q \times \mathbb W \to \mathcal P(Q) \), by the equations \( \hat \delta(q, \varepsilon) = \qty{q} \), and \( \hat \delta(q, wa) = \bigcup_{p \in \hat\delta(q,w)} \delta(p,a) \).
This produces a unique \emph{state set sequence}, not a deterministic state sequence.
We define \( \mathcal L(N) = \qty{w \mid \hat\delta(q_0,w) \cap F \neq \varnothing} \).
\begin{remark}
	Deterministic automata can be seen as a special case of nondeterministic automata.
\end{remark}
\begin{theorem}
	Let \( N \) be a nondeterministic automaton.
	Then there exists a deterministic automaton \( D \) such that \( \mathcal L(N) = \mathcal L(D) \).
\end{theorem}
\begin{proof}[subset construction]
	Let \( N = (\Sigma, Q, \delta, q_0, F) \).
	We define \( D = (\Sigma, \mathcal P(Q), \Delta, \qty{q_0}, G) \), where
	\[ \Delta(X, a) = \bigcup_{q \in X} \delta(q,a);\quad G = \qty{X \in \mathcal P(Q) \mid X \cap F \neq \varnothing} \]
	We show that these two automata produce the same language.
	Consider the state sequence of \( D \) on input \( w \).
	\[ X_0 = \qty{q_0};\quad X_{i+1} = \bigcup_{q \in X_i} \delta(q,a_i) \]
	The state set sequence of \( N \) on input \( w \) is
	\[ Y_0 = \qty{q_0};\quad Y_{i+1} = \bigcup_{q \in Y_i} \delta(q,a_i) \]
	Clearly, these exactly match, so \( X_i = Y_i \).
	So \( w \) is accepted by \( D \) if and only if it is accepted by \( N \).
\end{proof}
\begin{remark}
	Although this construction always works, we have transformed an automaton on \( n \) states into one on \( 2^n \) states.
\end{remark}
\begin{theorem}
	Let \( G \) be a regular grammar.
	Then there exists a nondeterministic automaton \( N \) such that \( \mathcal L(G) = \mathcal L(N) \).
\end{theorem}
\begin{proof}
	Let \( G = (\Sigma, V, P, S) \).
	Let \( H \not\in \Sigma \cup V \) be a new symbol, known as the \emph{halt state}.
	Let \( Q = V \cup \qty{H} \).
	Define \( N = (\Sigma, Q, \delta, S, \qty{H}) \) where
	\[ \delta(A,a) = \begin{cases}
		\qty{B \mid A \to aB \in P} & \text{if } A \to a \not\in P \\
		\qty{B \mid A \to aB \in P} \cup \qty{H} & \text{if } A \to a \in P
	\end{cases} \]
	We claim that \( \mathcal L(G) = \mathcal L(N) \).
	If \( w \in L(G) \), we have a sequence \( A_0, \dots, A_{n+1} \) of variables such that
	\[ S = A_0 \xrightarrow G_1 \dots \xrightarrow G_1 a_0\dots a_{n+1} A_{n+1} \xrightarrow G_1 w \]
	In particular, \( A_i \to a_i A_{i+1} \in P \) and \( A_{n+1} \to a_n \in P \).
	By definition of \( \delta \), there exists a sequence \( A_1, \dots, A_{n+1} \) such that \( A_{i+1} \in \delta(A_i, a_i) \) and \( H \in \delta(A_n, a_n) \).
	Hence \( H \in \hat\delta(S,w) \), so \( w \in \mathcal L(N) \).
	All implications are bi-implications so the converse holds.
\end{proof}

\subsection{The pumping lemma for regular languages}
\begin{definition}
	A language \( L \) \emph{satisfies the regular pumping lemma with pumping number \( n \)} if every word \( w \in L \) with length at least \( n \) can be split into three parts \( w = x y z \), such that \( \abs{y} > 0 \), \( \abs{xy} \leq n \) and for all \( k \in \mathbb N \), we have \( xy^kz \in L \).
	We call \( y \) a \emph{pump} for the word \( x y z \).
\end{definition}
\begin{theorem}[regular pumping lemma]
	Every regular language satisfies the pumping lemma.
\end{theorem}
\begin{remark}
	If any word can be pumped, the language must be infinite.
\end{remark}
\begin{proof}
	Let \( L \) be a regular language.
	Then there exists a deterministic automaton \( D = (\Sigma, Q, \delta, q_0, F) \) such that \( L = \mathcal L(D) \).
	We show that \( L \) has pumping number \( n = \abs{Q} \).
	Let \( w \in L(D) \) be a word with \( \abs{w} \geq n \).
	We can write \( w = a_0a_1 \dots a_{n-1} v \) where \( v \in \mathbb W \).

	The state sequence of \( D \) reading \( a_0, \dots, a_{n-1} \) is \( q_0, \dots, q_n \); it has length \( n + 1 \) since there are \( n \) state transitions.
	But there are only \( n \) states, so by the pigeonhole principle, one state must repeat.
	Let \( i < j \leq n \) such that \( q_i = q_j \).
	Let \( x = a_0 \dots a_{i-1}, y = a_i \dots a_{j-1}, z = a_j \dots a_{n-1} v \), so we have \( xyz = w \), \( \abs{y} > 0 \), \( \abs{xy} \leq n \) by construction.

	We show that we can pump the word.
	After reading \( x \), we have \( \hat\delta(q_0, x) = q_i \), and \( \hat\delta(q_i, y) = q_j = q_i \), and finally \( \hat\delta(q_i, z) = \hat\delta(q_j, z) \in F \).
	Hence, \( \hat\delta(q_0, xy^k) = q_i \) by induction on \( k \).
	In particular, \( \hat\delta(q_0, xy^kz) \in F \) as required.
\end{proof}
\begin{example}
	Let \( L = \qty{0^k 1^k, k > 0} \).
	We claim this is not a regular language.
	Suppose \( L \) is regular, and has pumping number \( N \).
	Consider the word \( 0^N 1^N \in L \); this word has more than \( N \) letters, so the word can be pumped.
	The pump must lie in the first \( N \) letters, all of which are zeroes.
	Pumping down, \( 0^{N-\ell} 1^N \in L \) where \( \ell \) is the length of the pump.
	This is a contradiction since the length of the pump is nonzero.
\end{example}
\begin{example}
	Let \( n > 0 \), and let \( L = \qty{0^n w, w \in \mathbb W} \).
	We show this is regular, but any deterministic automaton \( D \) such that \( L = \mathcal L(D) \) has more than \( n \) states.
	For regularity, we can simply write down a grammar.
	\[ P = \qty{S \to 0X_0, X_0 \to 0X_1, \dots, X_{n-2} \to 0X_{n-1}, X_{n-2} \to 0, X_{n-1} \to 0, X_{n-1} \to 1, X_{n-1} \to 0X_{n-1}, X_{n-1} \to 1X_{n-1}} \]
	This has exactly \( n + 1 \) states.
	Suppose that an automaton with at most \( n \) states has the same language.
	Then \( L \) satisfies the pumping lemma with pumping number \( n \).
	In particular, we can pump down the word \( 0^n \), obtaining a word with fewer zeroes, and this is not in the language.
\end{example}
\begin{example}
	Some non-regular languages also satisfy the pumping lemma.
	Let \( \Sigma = \qty{0,1} \).
	If a word \( w \in \mathbb W \) contains at least one zero, we say the \emph{tail} of the word is the number of ones that follow the last zero.
	Let \( X \subseteq \mathbb N \) be an arbitrary set of naturals, and define \( L_X \) to be the set of words that contain no zeroes, or have a tail which lies in \( X \).
	If \( X \neq Y \), we have \( L_X \neq L_Y \), so \( L \) is an injection from \( \mathcal P(\mathbb N) \) to the space of languages on \( \Sigma \).
	Since there are uncountably many \( X \subseteq \mathbb N \), but there are only countably many regular languages, there must be some non-regular languages of the form \( L_X \).

	We claim that all \( L_X \) satisfy the pumping lemma, so then there must be some \( L_X \) which are non-regular which satisfy the pumping lemma.
	Let \( X \subseteq \mathbb N \); we claim this has pumping number 2.
	Let \( w \in L_x \) such that \( \abs{w} \geq 2 \).

	Suppose \( w \) starts with a zero, so \( w = 0z \).
	Then let \( x = \varepsilon, y = 0 \), so \( w = xyz \).
	Pumping up does not change the tail; pumping down either does not change the tail or there are now no zeroes, but in either case, the new word lies in the language.
	
	Conversely, suppose \( w \) starts with a one, so \( w = 1z \).
	Let \( x = \varepsilon, y = 1 \), so \( w = xyz \) as before.
	If \( z \) contains no zeroes, after pumping \( y \), there are still no zeroes, so the new word is in the language.
	If \( z \) contains a zero, there is a tail, and pumping \( y \) does not influence the tail.
	Hence, the pumping lemma is satisfied.
\end{example}

\subsection{Closure properties}
We have already shown that regular languages are closed under concatenation and union.
We will now show that they are closed under complementation, intersection, and difference.
For this, it suffices to show they are closed under complementation, because intersection and difference can be expressed in terms of complement and union.

Consider an automaton \( D = (\Sigma, Q, \delta, q_0, F) \).
Without loss of generality, we can ensure that \( \delta(q_i,a) \neq q_0 \) for all \( i, a \).
Now define \( D' = (\Sigma, Q, \delta, q_0, \mathbb Q \setminus (F \cup \qty{q_0})) \).
Then, \( \mathcal L(D') = \mathbb W^+ \setminus \mathcal L(D) \).

There is an alternative construction to obtain union and intersection, known as the \emph{product automaton} construction.
Let \( D = (\Sigma, Q, \delta, q_0, F) \) and \( D' = (\Sigma, Q', \delta', q_0', F') \).
We can define the pointwise product \( D'' = (\Sigma, Q \times Q', \delta \times \delta', (q_0, q_0'), F'') \), where \( (\delta \times \delta')((q,q'),a) = (\delta(q,a), \delta'(q',a)) \), and either \( F'' = \qty{(q,q') \mid q \in F, q' \in F'} \) or \( F'' = \qty{(q,q') \mid q \in F \text{ or } q' \in F'} \).
We can see that the language generated by this new automaton is \( \mathcal L(D) \cap \mathcal L(D') \) or \( \mathcal L(D) \cup \mathcal L(D') \).
