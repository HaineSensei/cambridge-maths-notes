\subsection{Definition}
A register machine uses an alphabet \( \Sigma \), has finitely many states, and finitely many \emph{registers}, which are last-in first-out storage units containing a word \( w \in \mathbb W \).
The machine is able to access the last letter of the word, remove it, or push a new letter.
A \emph{configuration} or \emph{snapshot} of length \( n+1 \) is a tuple of the form \( (Q, w_0, \dots, w_n) \in \mathbb Q \times \mathbb W^{n+1} \).
A configuration defines the state of the computation at a particular point in time.

The transition function should now be of the form \( \delta \colon Q \times \mathbb W^{n+1} \to Q \times \mathbb W^{n+1} \).
However, not every such function represents a real computation; there are uncountably many such functions, and the action on the registers is unrestricted.
\begin{definition}
	Let \( \Sigma \) be an alphabet, and \( Q \) be a nonempty finite set of states.
	A tuple of the form
	\begin{align*}
		(0,k,a,q) &\in \mathbb N \times \mathbb N \times \Sigma \times Q \\
		(1,k,a,q,q') &\in \mathbb N \times \mathbb N \times \Sigma \times Q \times Q \\
		(2,k,q,q') &\in \mathbb N \times \mathbb N \times Q \times Q \\
		(3,k,q,q') &\in \mathbb N \times \mathbb N \times Q \times Q \\
	\end{align*}
	is called a \emph{\( (\Sigma, Q) \)-instruction}.
	For improved readability, we write
	\begin{align*}
		+(k,a,q) &= (0,k,a,q) \\
		?(k,a,q,q') &= (1,k,a,q,q') \\
		?(k,\varepsilon,q,q') &= (2,k,q,q') \\
		-(k,q,q') &= (3,k,q,q')
	\end{align*}
\end{definition}
Intuitively,
\begin{itemize}
	\item \( +(k,a,q) \) represents pushing the letter \( a \) onto register \( k \), then advancing to state \( q \).
	\item \( ?(k,a,q,q') \) checks if the letter \( a \) is currently at the top of the stack \( q \).
		If so, we advance to state \( q \), and otherwise, we advance to state \( q' \).
	\item \( ?(k,\varepsilon,q,q') \) checks if the stack \( q \) is empty.
		If so, we advance to state \( q \), and otherwise, we advance to state \( q' \).
	\item \( -(k,q,q') \) pops the topmost letter from register \( k \).
		If the register was already empty, we advance to state \( q \), and otherwise, we advance to state \( q' \).
\end{itemize}
These semantics are defined formally later.
Let \( \Instr(\Sigma, Q) \) be the set of \( (\Sigma,Q) \)-instructions.
This is in principle an infinite set, but finite if \( k \) is bounded.
\begin{definition}
	A tuple \( M = (\Sigma, Q, P) \) is called a \emph{\( \Sigma \)-register machine} if \( \Sigma \) is an alphabet, \( Q \) is a finite set of \emph{states} with two distinguished states \( q_S \neq q_H \), called the \emph{start state} and \emph{halt state} respectively, and \( P \colon Q \to \Instr(\Sigma,Q) \) is the \emph{program}.
	If \( Q = \qty{q_0, \dots, q_n} \), we can describe \( P \) as a finite collection of \emph{program lines} \( q_i \mapsto P(q_i) \).
	Since \( Q \) is finite, only finitely many registers \( k \) are referenced by \( P \); we call the largest such \( k \) the \emph{upper register index} of \( M \).
\end{definition}
\begin{definition}
	Let \( M \) be a register machine with upper register index \( n \) and \( \vb w = (w_0, \dots, w_n) \in \mathbb W^{n+1} \).
	For configurations \( C, C' \), we say \( M \) \emph{transforms} \( C \) into \( C' \) if one of the following holds.
	\begin{itemize}
		\item \( P(q) = +(k,a,q') \) and \( C' = (q', w_0, \dots, w_{k-1}, w_k a, w_{k+1}, \dots, w_m) \).
		\item \( P(q) = ?(k,a,q',q'') \), and
		\begin{itemize}
			\item \( w_k = wa \) for some \( w \) and \( C' = (q',w_0, \dots, w_m) \), or
			\item \( w_k \neq wa \) for all \( w \) and \( C' = (q'', w_0, \dots, w_m) \).
		\end{itemize}
		\item \( P(q) = ?(k,\varepsilon,q',q'') \), and
		\begin{itemize}
			\item \( w_k = \varepsilon \) and \( C' = (q',w_0, \dots, w_m) \), or
			\item \( w_k \neq \varepsilon \) and \( C' = (q'', w_0, \dots, w_m) \).
		\end{itemize}
		\item \( P(q) = -(k,q',q'') \), and
		\begin{itemize}
			\item \( w_k = \varepsilon \) and \( C' = (q',w_0, \dots, w_m) \), or
			\item \( w_k = wa \) and \( C' = (q'', w_0, \dots, w_{k-1}, w, w_{k+1}, \dots, w_m) \).
		\end{itemize}
	\end{itemize}
	Then we define the \emph{computation sequence} of \( M \) with input \( \vb w \) by \( C(0,H,\vb w) = (q_S,\vb w), C(k+1,M,\vb w) = C' \) where \( M \) transforms \( C(k,M,\vb w) \) into \( C' \).
\end{definition}
\begin{remark}
	This recursive definition requires that the length of \( \vb w \) is at least \( n + 1 \), where \( n \) is the upper register index.
	By convention, if \( \vb w \) is too short, we pad it with copies of the empty word \( \varepsilon \).
\end{remark}
\begin{remark}
	As defined above, all computation sequences are infinite, because every configuration is transformed by \( M \) into some other.
\end{remark}
\begin{definition}
	We say that the computation of \( M \) with input \( w \) \emph{halts at time \( k \)} or \emph{in \( k \) steps} if \( k \) is the smallest natural such that \( C(k,M,\vb w) = (q_H,\vb v) \).
	In this case, we say that \( \vb v \) is the \emph{register content at time of halting}, or the \emph{output} of the computation.
	If such a \( k \) does not exist, we say the computation \emph{does not halt}.
\end{definition}
\begin{definition}
	We say that register machines \( M, M' \) are \emph{strongly equivalent} if for all \( k \) and \( \vb w \), \( C(k,M,\vb w) \) and \( C(k,M',\vb w) \) have the same register content, and for all \( \vb w \), we have that \( M \) halts after \( k \) steps with input \( \vb w \) if and only if \( M' \) halts after \( k \) steps with input \( \vb w \).
\end{definition}
\begin{remark}
	If \( \abs{Q} = \abs{Q'} \), then for every \( (\Sigma, Q, P) \) there exists a strongly equivalent register machine \( (\Sigma, Q', P') \) by relabelling the states in \( P \).
\end{remark}

\subsection{The padding lemma}
\begin{proposition}
	Let \( M \) be a register machine.
	Then there are infinitely many different register machines that are strongly equivalent to \( M \).
\end{proposition}
\begin{proof}
	Let \( M = (\Sigma, Q, P) \).
	The register machine completely determines the computation sequence, so after adding a new state \( \hat q \) to \( Q \), \( \hat q \) is never a state in any computation sequence.
	So \( (\Sigma, Q \cup \qty{\hat q}, P \cup \qty{\hat p}) \) is strongly equivalent to \( M \) for any program line \( \hat p \) for \( \hat q \).
\end{proof}
\begin{proposition}
	Up to strong equivalence, there are only countably many register machines.
\end{proposition}
\begin{proof}
	Only the cardinality of \( Q \) matters up to strong equivalence.
	Let \( M_{n,k} \) be the collection of register machines with a fixed state set with \( \abs{Q} = n \) and uppper register index at most \( k \).
	By checking cases, we find \( \abs{\Instr(\Sigma,Q)} = (k+1)n\abs{\Sigma} + (k+1)n^2\abs{\Sigma} + (k+1)n^2 + (k+1)n^2 = N_{n,k} \), which is finite.
	Therefore, there are \( N_{n,k}^n \) different programs, and hence \( \abs{M_{n,k}} = N_{n,k}^n \) is finite.
	Then the collection of all register machines up to strong equivalence is \( \bigcup_{n,k} M_{n,k} \) which is countable.
\end{proof}

\subsection{Performing operations and answering questions}
\begin{definition}
	An \emph{operation} is a partial function \( f \colon \mathbb W^{n+1} \rightharpoonup \mathbb W^{n+1} \).
	We write \( f(\vb w) \downarrow \) if \( w \) lies in the domain of \( f \), and we say the operation \emph{is defined} or \emph{converges}.
	We write \( f(\vb w) \uparrow \) otherwise, and say that the operation is \emph{undefined} or \emph{diverges}.
	A register machine \( M \) \emph{performs} an operation \( f \) if for all \( \vb w \), \( f(\vb w) \downarrow \) if and only if \( M \) halts on input \( \vb w \), and in this case, the register content at time of halting is \( f(\vb w) \).
\end{definition}
\begin{example}
	The operation `never halt' is the empty function, \( \dom f = \varnothing \).
	Then any program that never references the halt state in the right hand side of a program line performs this operation.
	For example, \( q_S \mapsto +(0,a,q_S) \) and \( q_H \mapsto +(0,a,q_S) \) suffices.
\end{example}
\begin{remark}
	There are many register machines that perform the same operation, including many that are not strongly equivalent.
\end{remark}
\begin{example}
	The operation `halt without doing anything' is the function \( f(\vb w) = \vb w \) with \( \dom f = \mathbb W^{n+1} \).
	An example of a program to perform this is \( q_S \mapsto ?(0,a,q_H,q_H) \).
	This halts after one step, and preserves the register content.
\end{example}
\begin{definition}
	A \emph{question with \( k+1 \) answers} \( \mathsf Q \) is a partition of \( \mathbb W^{n+1} \) into \( k + 1 \) sets \( A_i \).
	A register machine \emph{answers a question} if it has \( k + 1 \) \emph{answer states} \( \overline q_i \), and upon input of \( \vb w \), after finitely many steps its configuration is \( (\overline q_i, \vb w) \) for the value of \( i \) where \( \vb w \in A_i \).
\end{definition}
\begin{example}
	The question `is register \( i \) empty' is performed by \( q_S \mapsto ?(i, \varepsilon, \overline q_Y, \overline q_N) \).
	The question `is the final letter in register \( i \) the letter \( a \)' is performed by \( q_S \mapsto ?(i, a, \overline q_Y, \overline q_N) \).
\end{example}
The following lemma allows us to concatenate register machines, or alternatively, to perform subroutines.
\begin{lemma}[concatenation]
	Let \( M \) perform \( F \colon \mathbb W^{n+1} \rightharpoonup \mathbb W^{n+1} \), and \( M' \) perform \( F' \colon \mathbb W^{n+1} \rightharpoonup \mathbb W^{n+1} \).
	Then we can construct a register machine \( \hat M \) which performs \( F' \circ F \).
\end{lemma}
\begin{remark}
	If \( F(\vb w) \downarrow \), then \( (F' \circ F)(\vb w) \downarrow \).
	If \( F(\vb w) \uparrow \) and \( F'(F(\vb w)) \downarrow \), then \( (F' \circ F)(\vb w) \downarrow \).
	Otherwise, \( (F' \circ F)(\vb w) \uparrow \).
\end{remark}
\begin{proof}
	We may assume without loss of generality that the state sets of the two machines are disjoint.
	We define \( \hat Q = Q \cup Q' \setminus \qty{q_H} \).
	We write \( P^\star \) for the program \( P \) with the rule \( q_H \mapsto P(q_H) \) removed, and then all instances of \( q_H \) replaced with \( q_S' \).
	We then define \( \hat P = P^\star \cup P' \).
	Then \( \hat M = (\Sigma, \hat Q, \hat P) \) clearly performs \( F' \circ F \).
\end{proof}
\begin{lemma}[case distinction]
	Let \( \mathsf Q \) be a question with \( k + 1 \) answers.
	Let \( F_i \colon \mathbb W^{n+1} \rightharpoonup \mathbb W^{n+1} \) be operations for \( i \leq k \).
	Let \( M \) be a register machine that answers \( \mathsf Q \), and let \( M_i \) be register machines that perform \( F_i \).
	Then there is a register machine that performs the operation given by \( G(\vb w) = F_i(\vb w) \) if \( \vb w \in A_i \).
\end{lemma}
\begin{proof}
	We assume that \( Q \) is disjoint from each \( Q_i \), and \( \bigcap_{i \leq k} Q_i = \qty{q_H} \).
	Let \( P_i^\star \) be \( P_i \) where all occurrences of \( q_{S,i} \) are replaced with the \( i \)th answer state \( \overline q_i \).
	Define \( Q^\star = Q \cup \bigcup_{i \leq k} Q_i \setminus \qty{q_{S,i}} \) and \( P^\star = P \cup \bigcup_{i \leq k} P_i^\star \).
	Then \( M^\star = (\Sigma, Q^\star, P^\star) \) performs \( G \).
\end{proof}

\subsection{Register machine API}
We can perform many different operations and answer many different questions using register machines.
We say that a register is \emph{unused} if no program line references it.
A register is \emph{empty} if it contains the empty word.
Registers that are used only for computation and not the output are sometimes called \emph{scratch space} or \emph{scratch registers}.
\begin{itemize}
	\item Consider
	\[ F(\vb w) = \begin{cases}
		\vb w & w_i \neq \varepsilon \\
		\uparrow & w_i = \varepsilon
	\end{cases} \]
	The question `is register \( i \) empty' is performed by a register machine, and in this case, the `never halt' operation can be performed; in the other case, the `halt without doing anything' operation can be performed.
	\item The operation `delete the final letter of register \( i \) if it exists' is performed by the program \( q_S \mapsto -(i,q_H,q_H) \).
	\item The operation `add letter \( a \) to register \( i \)' is performed by \( q_S \mapsto +(i,a,q_H) \).
	Note that this machine also performs the operation `guarantee that the \( i \)th register is nonempty'.
	\item The operation `delete the content of register \( i \)' is performed by \( q_S \mapsto -(i,q_H,q_S) \).
	\item We can perform the operation `add a fixed word \( w \) to register \( i \)'.
	If \( w = a_0 \dots a_\ell \), we use the concatenation lemma to perform the operation `add letter \( a_j \) to register \( i \)' for each letter in the word.
	\item The operation `replace the register content of \( i \) with the word \( w \)' can be performed by concatenating the operations `delete the content of register \( i \)' and `add \( w \) to register \( i \)'.
	\item We can answer the question `what is the final letter of register \( i \)'.
	This question has \( \abs{\Sigma} + 1 \) answers, since the register could be empty.
	For each letter \( a_j \in \Sigma \), we ask the question `does register \( i \) end in letter \( a_j \)', and if yes, go to the corresponding answer state \( \overline q_j \), and if not, go to a state that asks the next question in the sequence.
	If no question answers `yes', the register is empty, and we go to an answer state \( \overline q_\varepsilon \).
	\item In particular, we can perform the operation `copy the final letter of register \( i \) into register \( j \) if it exists', by asking what this letter is, and then in each case, pushing the relevant letter onto register \( j \).
	\item We can also `move the final letter of register \( i \) into register \( j \) if it exists' by first copying the letter and then removing the original from register \( i \).
	\item The operation `move the content of register \( i \) into register \( j \) in reverse order' is accomplished by repeatedly moving a single letter until no more letters lie in register \( i \).
	\item The operation `move the content of register \( i \) into register \( j \) in the correct order' can be performed by considering an unused empty register \( k \).
	We move the register content from \( i \) to \( k \) in reverse order and then from \( k \) to \( j \) in reverse order.
	\item The operation `reverse the content of register \( i \)' is performed by moving it in reverse order to an unused empty register \( j \), and then moving this into \( i \) in the correct order.
	\item The operation `move the content of register \( i \) into registers \( j \) and \( k \) in reverse order' is easily performed by copying the final letter of register \( i \) into \( j \) and then into \( k \), then removing the final letter in register \( i \) iteratively until it is empty.
	\item The operation `copy the content of register \( i \) into register \( j \) in reverse order' is accomplished by moving the content of register \( i \) into \( j \) and an unused empty register \( k \), and then moving the register content of \( k \) into \( i \) in reverse order.
	\item The operation `copy the content of register \( i \) into register \( j \) in the correct order' is accomplished by copying in the reverse order, and then reversing the content of register \( j \).
	\item Consider the question `is the content of register \( i \) the word \( w \)'.
	Let \( w = a_0 \dots a_k \).
	We define the subroutine \( S_\ell \) to answer the question `is \( q_\ell \) the final letter of register \( i \)'.
	If no, move to a state \( q_N \).
	If yes, move the final letter to an unused empty register \( k \) and run subroutine \( S_{\ell-1} \), or if \( \ell = 0 \), move to a state \( q_Y \).
	At state \( q_N \) we move the content of \( k \) to \( i \) and answer \( \overline q_N \), and at state \( q_Y \) we move the content of \( k \) to \( i \) and answer \( \overline q_Y \).
\end{itemize}

\subsection{Computable functions and sets}
\begin{remark}
	A lot of computations require the use of scratch space, and we want to reduce the mathematical information related to this scratch space.
	In the following definition, only register zero is considered real output; all other registers are considered scratch space.
\end{remark}
\begin{definition}
	Let \( M \) be a register machine, and let \( k \in \mathbb N \).
	Then we define \( f_{M,k} \colon \mathbb W^k \rightharpoonup \mathbb W \) by \( f_{M,k}(\vb w) \uparrow \) when \( M \) does not halt on input \( \vb w \), and \( f_{M,k}(\vb w) = v_0 \) when \( M \) halts on input \( \vb w \) with halting register content \( \vb v \).
\end{definition}
Note that if \( M, M' \) are strongly equivalent, \( f_{M,k} = f_{M',k} \) for all \( k \).
The converse does not hold.
For the special case of \( k = 1 \), we also write \( W_M = \dom f_{M,1} \).
\begin{definition}
	A partial function \( f \colon \mathbb W^k \rightharpoonup \mathbb W \) is called \emph{computable} if there is a register machine \( M \) such that \( f = f_{M,k} \).
\end{definition}
\begin{remark}
	There are only countably many computable functions, because there are only countably many register machines up to strong equivalence.
	For each computable function \( f \), there are infinitely many register machines \( M \) such that \( f = f_{M,k} \), since any register machine has infinitely many other strongly equivalent register machines.
	Due to the concatenation lemma and the case distinction lemma, computable functions are closed under concatenation and case distinction.
\end{remark}
\begin{example}
	The identity function on \( \mathbb W \) is computable.
	Consider \( c \colon \mathbb W^k \to \mathbb W \) is given by \( c(\vb w) = v \) for a fixed \( v \).
	The operation `replace the content of register \( 0 \) with \( v \)' is performable on a register machine, so \( c \) is computable.
	The projection \( \pi_i \colon \mathbb W^k \to \mathbb W \) given by \( \pi_i(\vb w) = w_i \) is computable since the operation `replace the content of register \( 0 \) with register \( i \)' can be performed on a register machine by emptying register \( 0 \) and then moving the content of register \( i \) to register \( 0 \).
\end{example}
\begin{definition}
	Let \( X \subseteq \mathbb W^k \).
	We say that a total function \( f \colon \mathbb W^k \to \mathbb W \) is \emph{a characteristic function of \( X \)} if \( f(\vb w) \neq \varepsilon \) if and only if \( \vb w \in X \).
	Let \( a \in \Sigma \).
	We say that \( f \) is \emph{the characteristic function of \( X \)} if \( f(\vb w) = a \) if \( \vb w \in X \) and \( f(\vb w) = \varepsilon \) otherwise.
\end{definition}
We use the notation \( \chi_X \) for the characteristic function.
\begin{definition}
	A set \( X \subseteq \mathbb W^k \) is \emph{computable} if the characteristic function \( \chi_X \) of \( X \) is computable.
\end{definition}
Note that a language is a set of words, so we can now reason about computability of languages.
\begin{definition}
	Let \( X \subseteq \mathbb W^k \).
	A partial function \( f \colon \mathbb W^k \rightharpoonup \mathbb W \) is called \emph{a pseudocharacteristic function of \( X \)} if \( \dom f = X \).
	\( f \) is called \emph{the pseudocharacteristic function of \( X \)} if \( f(\vb w) = a \) if \( w \in X \), and undefined otherwise.
\end{definition}
We use the notation \( \psi_X \) for the pseudocharacteristic function.
\begin{definition}
	A set \( X \subseteq \mathbb W^k \) is \emph{computably enumerable} if the pseudocharacteristic function \( \psi_X \) is computable.
\end{definition}
\begin{remark}
	We will show that every computable set of computably enumerable, but the converse does not hold.
	We will also show that the computable enumerable sets are exactly the type 0 (context-free or noncontracting) languages, and that the class of computable languages is properly contained between type 1 and type 0.
\end{remark}

\subsection{Computability of languages}
\begin{proposition}
	Let \( X \subseteq \mathbb W^k \).
	Then:
	\begin{enumerate}
		\item \( X \) is computable if and only if \( X^c \) is computable.
		\item \( X \) is computably enumerable if and only if there exists a register machine \( M \) such that \( X = \dom f_{M,k} \).
		\item \( X \) is computable implies that \( X \) is computably enumerable.
	\end{enumerate}
\end{proposition}
\begin{proof}
	To simplify notation we consider the case \( k = 1 \).
	Note that if \( g \) and \( h \) are computable, then by the case distinction lemma, so is \( f \) defined by \( f(w) = g(w) \) if \( w \neq \varepsilon \), and \( f(w) = h(w) \) if \( w = \varepsilon \).

	For the first part, consider the computable function \( f_1 \) given by \( g(w) = \varepsilon \) and \( h(w) = a \).
	Then \( f_1 \circ \chi_X = \chi_{X^c} \), \( f_1 \circ \chi_{X^c} = \chi_X \).

	Now consider \( f_2 \) given by \( g(w) = a \) and \( h(w) = \varepsilon \).
	If \( X = \dom f \), then \( \psi_X = f_2 \circ f \).

	Finally, consider \( f_3 \) given by \( g(w) = a \) and \( h(w) \uparrow \).
	Then \( \psi_X = f_3 \circ \chi_X \).
\end{proof}
\begin{theorem}
	Every regular language is computable.
\end{theorem}
\begin{proof}
	Let \( L \) be such a regular language.
	Let \( D = (\Sigma, Q, \delta, q_0, F) \) be a deterministic automaton such that \( L = \mathcal L(D) \).
	The first step in our program is to reverse the content of register 0 into register 1, because register machines read words in the opposite order of deterministic automata.
	For each \( q \in Q \), the register machine will have a set of states \( Q_q \) that indicate that we are currently mimicking \( D \) in state \( q \).
	We will now move into the state set \( Q_{q_0} \).

	When moving into each state set \( Q_q \), our program will read the final letter of register 1.
	If there are no letters in register 1, go to a fixed accepting state if \( q \in F \) and the non-accepting state if \( q \not\in F \).
	Otherwise, let \( b \) be the last letter in register 1.
	Remove \( b \) from register 1, and go to state set \( Q_{\delta(q,b)} \).
	We implicitly repeat this step, since we have now transitioned into a state set.

	If the machine is in the given accepting state, we empty register 0, add \( a \) to register 0, and then halt.
	If the machine is in the non-accepting state, we empty register 0, and then halt.
\end{proof}

\subsection{The shortlex ordering}
We wish to create an order \( < \) on \( \mathbb W \) such that \( (\mathbb N, <) \) is order-isomorphic to \( (\mathbb W, <) \).
We first fix an arbitrary total order \( < \) on \( \Sigma \).
\begin{definition}
	The \emph{shortlex ordering} on \( \mathbb W \) given by an ordering of \( \Sigma \) is given by \( w < v \) when
	\begin{enumerate}
		\item \( \abs{w} < \abs{v} \); or
		\item \( \abs{w} = \abs{v} \) but \( w \neq v \), and for the least \( m \) such that the \( m \)th characters differ, the \( m \)th character of \( w \) is less than the \( m \)th character of \( v \).
	\end{enumerate}
\end{definition}
This ordering first checks length, then the lexicographic ordering.
This is a total ordering on \( \mathbb W \); it is irreflexive, transitive, and trichotomous.
The empty word is the least element.
\begin{example}
	Let \( \Sigma = \qty{0,1} \), and fix \( 0 < 1 \).
	Then an initial segment of the ordering is
	\[ \varepsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, 101, 110, 111, 0000, \dots \]
	We can identify each word with a natural number, given by its index in this sequence, counting from zero.
	There are \( 2^k \) words of length \( k \), so the index of the natural number associated to the word \( 0^k \) is exactly \( 2^k - 1 \).

	We can naturally extend the operations of addition and multiplication on the set of words by acting on the index of the word in this ordering.
	For example, \( 10 + 01 = 010 \), because the associated index of \( 10 \) is \( 5 \), the index of \( 01 \) is \( 4 \), and the index of \( 010 \) is \( 9 \).
	This gives \( \mathbb W \) the structure of a commutative semiring.
\end{example}
\begin{theorem}
	The shortlex ordering has the same order type as \( \mathbb N \).
	We write \( (\mathbb N, <) \cong (\mathbb W, <) \).
\end{theorem}
\begin{proof}
	For a fixed \( w \), the set \( \qty{v \mid v < w} \) is finite.
	Therefore, the function \( \# \colon \mathbb W \to \mathbb N \) given by \( \#(w) = \abs{\qty{v \mid v < w}} \) is well-defined and is an order isomorphism.
\end{proof}
\begin{theorem}
	The set \( \qty{(v,w) \mid v < w} \) is computable.
	The \emph{successor function} \( s \colon \mathbb W \to \mathbb W \) with \( \#(s(w)) = \#(w)+1 \) is computable.
\end{theorem}
\begin{proof}
	The question to determine the ordering of \( \abs{w_i} \) and \( \abs{w_j} \) can be answered by a register machine by copying \( i, j \) into empty registers and repeatedly removing letters until one or both is empty.
	If they have the same length, we again copy \( i, j \) into empty registers in the reverse order, and check and remove each letter until a difference is found.

	To compute \( s(w) \) for a word \( w \), we find the last letter in \( w \) that is not the largest letter in the ordering.
	Replace this letter with the next letter in the ordering, and replace all subequent letters with the least letter in the ordering.
	If all \( k \) letters are the greatest letter, output the least letter \( (k + 1) \)-many times.
\end{proof}

\subsection{Church's recursive functions}
The class of recursive functions is defined inductively.
\begin{definition}
	The \emph{basic functions} are
	\begin{align*}
		\pi_{k,i} &\colon \mathbb W^k \to \mathbb W \\
		c_{k,\varepsilon} &\colon \mathbb W^k \to \mathbb W \\
		s &\colon \mathbb W \to \mathbb W
	\end{align*}
	where \( \pi_{k,i}(\vb w) = w_i \), \( c_{k,\varepsilon}(\vb w) = \varepsilon \), and \( \# s(w) = \# w + 1 \).
\end{definition}
We call \( \pi_{k,i} \) the \emph{projection} functions, \( c_{k,\varepsilon} \) the \emph{constant} functions, and \( s \) the \emph{successor} function.

Let \( f \colon \mathbb W^m \to \mathbb W \) and \( g_1, \dots, g_m \colon \mathbb W^k \to \mathbb W \).
Then the \emph{composition} is \( h(\vb w) = f(g_1(\vb w), \dots, g_m(\vb k)) \).

Let \( f \colon \mathbb W^k \rightharpoonup \mathbb W \) and \( g \colon \mathbb W^{k+2} \rightharpoonup \mathbb W \).
Then the partial function \( h \colon \mathbb W^{k+1} \rightharpoonup \mathbb W \) defined by \( h(\vb w, \varepsilon) = f(\vb w) \) and \( h(\vb w, s(v)) = g(\vb w, v, h(\vb w, v)) \) is a function defined by \emph{recursion}.

Let \( f \colon \mathbb W^{k+1} \rightharpoonup \mathbb W \).
Then the function \( h \colon \mathbb W^k \rightharpoonup \mathbb W \) defined by
\[ h(\vb w) = \begin{cases}
	v & \text{if for all \( u \leq v \), we have \( f(u) \downarrow \) and \( v \) is \( < \)-minimal such that \( f(\vb w, v) = \varepsilon \)} \\
	\uparrow & \text{if for all \( v \), we have \( f(\vb w, v) \neq \varepsilon \)}
\end{cases} \]
is a function defined by \emph{minimisation}.
\begin{remark}
	If a class of functions has the basic functions and is closed under composition, it has all constant functions \( c_{k,v}(\vb w) = v \), because if \( v = s^k(\varepsilon) \), \( c_{k,v} = s^k \circ c_{k,\varepsilon} \).
\end{remark}
\begin{definition}
	A class \( \mathcal C \) of partial functions is closed under composition, recursion, and minimisation if whenever \( f_1, \dots, f_\ell \in \mathcal C \), then the results of applying these operations also lie in \( \mathcal C \).
\end{definition}
\begin{remark}
	The class \( \mathcal P \) of all partial functions is closed under composition, recursion, and minimisation.
\end{remark}
\begin{definition}
	We call a partial function \emph{recursive} if it lies in the smallest class \( \mathcal C \) that contains the basic functions and is closed under composition, recursion, and minimisation.
	A partial function is \emph{primitive recursive} if it lies in the smallest class \( \mathcal C \) that contains the basic functions and is closed under composition and recursion.
\end{definition}
\begin{example}
	\( \pi_{1,0} \colon \mathbb W^1 \to \mathbb W \) is the identity function, which is primitive recursive.
	\( \pi_{3,2} \colon \mathbb W^3 \to \mathbb W \) defined by \( \pi_{3,2}(u,v,w) = w \) is primitive recursive as it is a basic function.
	The successor function \( s \colon \mathbb W \to \mathbb W \) is primitive recursive.
	The function \( s \circ \pi_{3,2} \) is primitive recursive, as the composition of primitive recursive functions.

	The function \( h \) defined by \( h(w,\varepsilon) = \pi_{1,0}(w) \) and \( h(w,s(v)) = s \circ \pi_{3,2}(w,v,h(w,v)) = s(h,w,v) \) is primitive recursive, which is exactly the addition function \( \# h(n,m) = \# n + \# m \).
	We can define multiplication and exponentiation in a similar way, and so all of these are primitive recursive.
\end{example}
We can encode recursive functions in trees.
Let \( T \) be a finitely branching tree, and define a labelling \( \ell \) on \( T \) with the labels
\begin{center}
	\begin{tabular}{c c c c}
		& label & arity & branching number \\
		projection & \( B_{k,i}^\pi \) & \( k \) & 0 \\
		constant & \( B_{k,i}^c \) & \( k \) & 0 \\
		successor & \( B^s \) & 1 & 0 \\
		composition & \( C_{n,k} \) & \( k \) & \( n + 1 \) \\
		recursion & \( R_k \) & \( k + 1 \) & 2 \\
		minimisation & \( M_k \) & \( k \) & 1
	\end{tabular}
\end{center}
\begin{definition}
	A tree \( T \) with a labelling \( \ell \) is called a \emph{recursion tree} if the branching of the tree corresponds exactly to the branching numbers of its labels, and
	\begin{enumerate}
		\item if \( \ell(s) = C_{n,k} \), then the first successor of \( s \) has a label of arity \( n \) and all other have labels with arity \( k \);
		\item if \( \ell(s) = R_k \), then the first successor of \( s \) has arity \( k \) and the other has arity \( k + 2 \);
		\item if \( \ell(s) = M_k \), then the successor has arity \( k \).
	\end{enumerate}
	A recursion tree is \emph{primitive} if it has no minimisation labels \( M_k \).
\end{definition}
The following recursion tree describes the addition function defined above.
\begin{center}
	\begin{tikzcd}
		& {R_1} \\
		{B_{1,0}^\pi} && {C_{1,3}} \\
		& {B^s} && {B_{3,2}^\pi}
		\arrow[no head, from=1-2, to=2-1]
		\arrow[no head, from=1-2, to=2-3]
		\arrow[no head, from=2-3, to=3-4]
		\arrow[no head, from=2-3, to=3-2]
	\end{tikzcd}
\end{center}
We can assign a (partial) recursive function \( f_{T,\ell} \) to every recursive tree \( (T, \ell) \).
If the tree is primitive, the function obtained is primitive recursive.
\begin{theorem}
	A partial function \( f \) is recursive if and only if there is a recursion tree \( (T, \ell) \) such that \( f = f_{T, \ell} \).
	It is primitive recursive if it admits a recursion tree that is primitive.
\end{theorem}
\begin{proof}
	We can obtain the associated partial function from a recursion tree by induction on the height on the tree.
	For the converse, it suffices to show that the class of functions \( f_{T,\ell} \) contains the basic functions and is closed under composition, recursion, and minimisation, which holds by construction.
\end{proof}
\begin{theorem}
	Every partial recursive function is computable.
\end{theorem}
\begin{proof}
	The basic functions have already been shown to be computable.
	Computable functions are closed under composition (previously called concatenation).
	So it suffices to show that the computable functions are closed under recursion and minimisation.

	Let \( f, g \) be computable functions; we want to show that \( h \) defined by \( h(\vb w, \varepsilon) = f(\vb w) \) and \( h(\vb w, s(v)) = g(\vb w, v, h(\vb w, v)) \) is computable.
	We describe a register machine.
	\begin{enumerate}
		\item Let \( k, \ell \) be two empty unused registers.
		\item Compute \( f(\vb w) \), and write the result to register \( \ell \).
			Note that if \( f(\vb w) \) is undefined, this produces the desired result.
		\item If \( v = \varepsilon \), output the content of register \( \ell \).
			Otherwise, apply the successor function \( s \) to register \( k \) and perform the following subroutine.
			\begin{enumerate}
				\item Compute \( g(\vb w, v, u) \) where \( u \) is the content of register \( \ell \), then overwrite register \( \ell \) with the result.
				\item Check whether \( v \) is equal to the register content of \( k \).
					If so, output register \( \ell \).
					Otherwise, apply \( s \) to register \( k \) and restart the subroutine.
			\end{enumerate}
	\end{enumerate}
	We now consider minimisation.
	Let \( f \) be computable.
	Let \( k \) be empty and unused.
	Perform the following subroutine.
	\begin{enumerate}
		\item Compute \( f(\vb w, u) \) where \( u \) is the content of register \( k \).
			If this result is undefined, this is the desired result.
		\item Check whether the computation result is empty.
			If it is not empty, output the register content of \( k \).
			Otherwise, apply the successor function \( s \) to \( k \) then restart the subroutine.
	\end{enumerate}
\end{proof}
\begin{remark}
	The proof showed that the computable functions are closed under recursion and minimisation, not just that all partial recursive functions are computable.
	Therefore, we can use recursion and minimisation directly to construct computable functions or register machines.
\end{remark}
Recall that there is a bijection \( z \colon \mathbb N \times \mathbb N \to \mathbb N \), called the \emph{Cantor zigzag function}.
\[ z(i,j) = \frac{(i+j)(i+j+1)}{2} + j \]
This gives a bijection \( \mathbb W \times \mathbb W \to \mathbb W \).
All of these operations are computable by register machines.
\begin{definition}
	Let \( v, w \) be words.
	Then we can \emph{merge} the two words into \( v \ast w \), which is the unique word such that \( \#(v \ast w) = z(\#v, \#w) \).
	We can \emph{split} a word \( w \) into \( u, v \) such that \( \#w = z(\#u, \#v) \).
	We write \( u = w_{(0)} \) and \( v = w_{(1)} \).
\end{definition}
Technically, splitting a word is not a computable function, since computable functions are defined to always have codomain \( \mathbb W \).
However, the operation of splitting a word can be performed.

\subsection{Choice of alphabet}
Consider an alphabet \( \Sigma \).
We then have a notion of computability for sets \( X \subseteq \Sigma^\star = \mathbb W \).
If \( \Sigma \subseteq \Sigma' \), then every \( \Sigma \)-register machine is a \( \Sigma' \)-register machine.
However, the notion of \( \Sigma' \)-computability is no stronger than \( \Sigma \)-computability.
One can show that computability over any alphabet \( \Sigma \) with \( \abs{\Sigma} \geq 2 \) is equivalent to computability over the set \( \qty{0,1} \) by encoding each letter as a binary string.
% TODO: Fill in from moodle

\subsection{Universality}
In this subsection, we aim to show that there is a \emph{universal} register machine, which is a machine that can mimic every register machine.
Let \( \Sigma \) be an alphabet, and add additional symbols
\[ \bm 0\ \bm 1\ \bm +\ \bm -\ \bm ?\ \bm (\ \bm )\ \bm ,\ \bm \mapsto\ \bm \square \]
We name the new alphabet \( \Sigma' \).

When we encode a mathematical object \( o \) as a word \( \Sigma'^\star \), we write the encoded result \( \code(o) \).
\begin{itemize}
	\item We can encode \( \mathbb N \) in binary using \( \bm 0 \) and \( \bm 1 \), for instance, \( \bm 1 \bm 0 \bm 0 \bm 1 \bm 1 = \code(19) \).
	\item If \( Q = \qty{q_0, \dots, q_k} \), we define \( \code(q_k) = \code(k) \).
	\item We encode instructions \( I \in \mathrm{Instr}(\Sigma, Q) \) using \( \bm +\ \bm -\ \bm ?\ \bm ,\ \bm (\ \bm ) \); for instance, \( \code(+(k,a,\ell)) = \bm +\bm(\code(k)\bm , a\bm ,\code(\ell)\bm ) \).
	\item We encode program lines by \( \code(q \mapsto I) = \code(q) \bm \mapsto \code(I) \).
	\item We encode a register machine with program \( P \) as \( \code(q_0 \mapsto P(q_0)) \bm , \ldots \bm , \code(q_n \mapsto P(q_n)) \).
	\item We encode sequences of words by \( \vb w \) by \( \code(\vb w) = \bm\square w_0 \bm\square \ldots \bm\square w_k \bm\square \).
	\item We encode configurations \( (q, \vb w) \) by \( \code(q)\code(\vb w) \).
\end{itemize}
% TODO: Fill in table
\begin{lemma}
	The function \( h \) defined by
	\[ h(w,u,v) = \begin{cases}
		\code(C(M,\vb w,\# v)) & \text{if there exist } M, \vb w \text{ such that } w = \code(M), u = \code(\vb w) \\
		\uparrow & \text{otherwise}
	\end{cases} \]
	is computable.
\end{lemma}
\begin{proof}
	Apply recursion with the operation given in the previous table.
	In particular, we define by recursion \( h(\code(M), \code(\vb w), \varepsilon) = \code(q_0)\code(\vb w) \) and \( h(\code(M), \code(\vb w), s(v)) = \code(C') \) where \( C' \) is the result of transforming \( h(\code(M), \code(\vb w, v)) \) by the machine \( M \).
\end{proof}
\begin{corollary}
	The \emph{truncated computation} function \( t_{M,k} \) defined by
	\[ t_{M,k}(\vb w, v) = \begin{cases}
		a & M \text{ has halted before time } \#v \text{ on input } \vb w \\
		\varepsilon & \text{otherwise}
	\end{cases} \]
	is computable.
\end{corollary}
\begin{proof}
	Using recursion on the function \( h \) from the previous lemma, we check all values of \( h \) for words \( u \) such that \( \# u < \# v \).
	If any of the values is in state \( q_H \), output \( a \), otherwise, output \( \varepsilon \).
\end{proof}
\begin{theorem}[the software principle]
	The function \( g \) defined by
	\[ g(v,u) = \begin{cases}
		f_{M,k}(\vb w) & \text{if } v = \code(M), u = \code(\vb w) \text{ and \( \vb w \) has length \( k \)} \\
		\uparrow & \text{otherwise}
	\end{cases} \]
	is computable.
\end{theorem}
\begin{proof}
	We have a computable function \( f \) that maps \( w, u, v \) to \( \code(C(M,\vb w, \# v)) \) if \( \code(M) = w \) and \( \code(\vb w) = u \) by the previous lemma.
	We start by checking whether \( w \) is a code for a register machine and \( u \) is a code for a \( k \)-tuple of words; if not, never halt.
	Write \( f' \) for the computable function mapping \( w, u, v \) to \( a \) if the state of \( f(w,u,v) \) is \( q_H \), and \( \varepsilon \) otherwise.
	We minimise \( f' \) to obtain the computable function \( h \), such that \( h(w,u) \) is the least \( v \) such that \( f(w,u,v) \) is in state \( q_H \) if it exists.
	If \( h(w,u) \) does not halt, then there is no step at which the computation halts, as expected, since \( g(w,u) \) should not halt in this case.
	If \( h(w,u) \) halts, consider the configuration \( C(M,\vb w, \#h(w,u)) \) and find the code for its 0th register, and write this into the actual 0th register.
\end{proof}
\begin{remark}
	A register machine \( U \) that computes \( g \) is called a \emph{universal register machine}.
	\( U \) has a finite amount of used registers and states, but can mimic the behaviour of any register machine using an arbitrarily large amount of registers and states.

	This allows us to streamline notation; for a word \( v \in \mathbb W \), we can write \( f_{v,k}(\vb w) = f_{U,2}(v,\code(w)) = f_{M,k}(w) \) if \( \code(M) = v \).
	Similarly, we can write \( W_v = \dom f_{v,1} \), so \( \qty{W_v \mid v \in \mathbb W} \) is the set of computably enumerable sets.
\end{remark}
\begin{theorem}[\( s \)--\( m \)--\( n \) theorem; parameter theorem]
	Let \( g \colon \mathbb W^{k+1} \rightharpoonup \mathbb W \) be computable.
	Then there exists a total computable function \( h \colon \mathbb W \to \mathbb W \) such that \( f_{h(v),k}(\vb w) = g(\vb w, v) \).
\end{theorem}
This process is called \emph{currying}, after Haskell Curry.
\begin{remark}
	\( g_v(\vb w) = g(\vb w, v) \) is a function in \( k \) variables.
	This is computable, so there is a mathematical function \( h \) such that \( g_v = f_{h(x),k} \), but this \( h \) is not \emph{a priori} computable.
\end{remark}
\begin{proof}
	First, the operation \( \vb w \mapsto (\vb w, v) \) is performed by a register machine \( M_v \); this is the register machine that writes \( v \) into register \( k \).
	Therefore, we have a computable function \( v \mapsto \code(M_v) \).
	Now, since \( g \) is computable, there is a register machine \( M \) such that \( f_{M,k+1} = g \).
	Therefore, \( g_v \) is computed by the sequence of register machines \( M_v \) then \( M \).
	We can computably concatenate two register machines, so we can compute a code for \( M \circ M_v \).
	Hence the function \( h(v) = \code(M \circ M_v) \) is total and computable.

	We must show that \( f_{h(v),k}(\vb w) = g(\vb w, v) \).
	Indeed, \( f_{h(v),k}(\vb w) = f_{\code(M \circ M_v), k}(\vb w) = f_{M \circ M_v, k}(\vb w) = g_v(\vb w) = g(\vb w, v) \) as required.
\end{proof}

\subsection{Computably enumerable sets}
Consider the sets
\[ \mathbb K_0 = \qty{(w, v) \mid f_{w,1}(v) \downarrow};\quad \mathbb K = \qty{w \mid f_{w,1}(w) \downarrow} \]
\begin{theorem}
	\( \mathbb K_0 \) and \( \mathbb K \) are computably enumerable.
\end{theorem}
\begin{proof}
	It suffices to show that \( \mathbb K_0, \mathbb K \) are the domains of computable functions.
	By the software principle, \( f_{U,2}(w,v) = f_{w,1}(v) \) and \( \dom f_{U,2} = \mathbb K_0 \) as required.
	Observe that the diagonal function \( \Delta(w) = (w, w) \) is computable, so \( f_{U,2} \circ \Delta \) is computable, and \( \dom(f_{U_2} \circ \Delta) = \mathbb K \).
\end{proof}
\begin{theorem}[the halting problem]
	Neither \( \mathbb K_0 \) nor \( \mathbb K \) are computable.
\end{theorem}
\begin{proof}
	We prove the result for \( \mathbb K_0 \).
	Suppose that \( \mathbb K_0 \) is computable, so the characteristic function \( \chi_{\mathbb K_0} \) is computable.
	Now, define
	\[ f(w) = \begin{cases}
		\uparrow & \text{if } \chi_{\mathbb K_0}(w,w) = a \\
		\varepsilon & \text{if } \chi_{\mathbb K_0}(w,w) = \varepsilon
	\end{cases} \]
	This is a computable function, so there is a machine \( d \in \mathbb W \) such that \( f_{d,1} = f \).
	Now,
	\[ f(d) \downarrow \iff f_{d,1}(d) \downarrow \iff (d,d) \in \mathbb K_0 \iff \chi_{\mathbb K_0}(d,d) = a \iff f(d) \uparrow \]
	The proof is almost exactly the same for \( \mathbb K \).
\end{proof}
\begin{definition}
	\( X \subseteq \mathbb W^k \) is called \( \Sigma_1 \) if there is a computable function \( Y \subseteq \mathbb W^{k+1} \) such that \( \vb w \in X \iff \exists y, (\vb w, y) \in Y \).
	We say \( X = p(Y) = \qty{\vb w \mid \exists y,\, (\vb w, y) \in Y} \) is the \emph{projection} of \( Y \).
	We say \( X \) is \( \Pi_1 \) if it is the complement of a \( \Sigma_1 \) set.
	We say \( X \) is \( \Delta_1 \) if it is \( \Sigma_1 \) and it is \( \Pi_1 \).
\end{definition}
\begin{remark}
	The notation \( \Sigma \) is chosen to symbolise an existential quantifier, and \( \Pi \) symbolises the universal quantifier.
	In logic, sums and existentials are related, and products and universal quantifiers are also related.
	\( \Delta \) is chosen for the German word \emph{Durchschnitt} (`intersection'), as \( \Delta_1 \) is the intersection of \( \Sigma_1 \) and \( \Pi_1 \).
\end{remark}
\begin{proposition}
	Every computable set is \( \Delta_1 \).
\end{proposition}
\begin{proof}
	By closure under complement, it suffices to show every computable set is \( \Sigma_1 \).
	The computable set \( Y = \qty{(\vb w, y) \mid \vb w \in X} \) has projection \( X \).
	Logically, this adds a trivial existential quantification.
\end{proof}
\begin{theorem}
	The computably enumerable sets are exactly the \( \Sigma_1 \) sets.
\end{theorem}
\begin{proof}
	Suppose \( X \) is computably enumerable.
	Then by definition, the pseudocharacteristic function \( \psi_X \) is computable.
	Then there exists a register machine \( M \) such that \( \psi_X = f_{M,k} \).
	We define \( Y = \qty{(\vb w, y) \mid t_{M,k}(\vb w, y) = a} \) where \( t_{M,k} \) is the truncated computation function for the register machine \( M \).
	\( Y \) is computable, since \( t_{M,k} = \chi_Y \).
	Then \( \vb w \in X \iff \psi_X(\vb w) \downarrow \iff \exists y,\, (\vb w, y) \in Y \) as required.

	Now suppose \( X \) is \( \Sigma_1 \).
	Let \( Y \) be a computable set such that \( X = p(Y) \).
	The characteristic function \( \chi_Y \) is computable.
	We apply minimisation to \( \chi_Y \) to obtain a function \( h \) such that \( h(\vb w) \) is the minimal \( y \) such that \( (\vb w, y) \in Y \).
	Then \( \dom h = p(Y) = X \), so \( X \) is the domain of a partial computable function as required.
\end{proof}
\begin{example}
	Let \( f \colon \mathbb W^2 \rightharpoonup \mathbb W \) be a partial computable function in two variables.
	Then \( X = \qty{w \mid \exists v,\, f(w, v) \downarrow} \) is computably enumerable.
	Note that \( f(w, v) \downarrow \) is not a computable predicate.
	Let \( M \) be a register machine such that \( f = f_{M,2} \), and let \( Z = \qty{(w, v_0, v_1) \mid t_{M,2}(w,v_0,v_1) = a} \).
	Clearly \( Z \) is computable.
	Define \( Y = \qty{(w, u) \mid (w, u_{(0)}, u_{(1)}) \in Z} \); this is also computable.
	Now,
	\[ \exists v,\, f(w,v) \downarrow \iff \exists v_0,\, \exists v_1,\, (w,v_0,v_1) \in Z \iff \exists u,\, (w,u_{(0)},u_{(1)}) \in Z \iff (w,u) \in Y \iff w \in p(Y) \]
	So \( X \) is \( \Sigma_1 \) as required.
\end{example}
\begin{remark}
	The previous argument is sometimes known as a \emph{zigzag argument}; a pair of existential quantifiers can be merged into a single existential by merging the two words.
	Hence, we can perform infinitely many computations in parallel.
\end{remark}
\begin{corollary}
	The computable sets are exactly the \( \Delta_1 \) sets.
\end{corollary}
\begin{proof}
	If \( X \) is computable, it must be \( \Delta_1 \) by a previous result.
	If \( X \) is \( \Delta_1 \), we can use a zigzag technique.
	We know that there are machines \( M, M' \) such that \( w \in X \iff \exists v,\, t_{M,k}(\vb w, v) = a \) and \( w \not\in X \iff \exists v,\, t_{M',k}(\vb w, v) = a \).
	Now, consider
	\[ f(\vb w, v) = \begin{cases}
		t_{M,k}(\vb w, v_{(1)}) & \#v_{(0)} \text{ is even} \\
		t_{M',k}(\vb w, v_{(1)}) & \#v_{(0)} \text{ is odd}
	\end{cases} \]
	This is computable.
	Apply minimisation to \( f \) to obtain a function \( h \) where \( h(\vb w) \) is the least \( v \) such that \( f(\vb w, v) \neq \varepsilon \).
	We output \( a \) if \( \#h(\vb w)_{(0)} \) is even, and \( \varepsilon \) if \( \#h(\vb w)_{(0)} \) is odd.
\end{proof}
\begin{corollary}
	\( \Sigma_1 \) is not closed under complementation.
\end{corollary}
\begin{proof}
	The complement of the halting problem \( \mathbb W \setminus \mathbb K \) is \( \Pi_1 \) and not \( \Delta_1 \), so not \( \Sigma_1 \).
\end{proof}
\begin{theorem}
	Every type 0 language is computably enumerable.
\end{theorem}
\begin{proof}
	Let \( G = (\Sigma, V, P, S) \) and let \( \Sigma' = \Omega \cup \qty{\bm\to} \).
	We encode derivations as \( \sigma_0 \bm\to \cdots \bm\to \sigma_n \); this is a \( \Sigma' \)-word.
	We say \( w \in (\Sigma')^\star \) is a \emph{derivation code} if \( w \) is of this form with \( (\sigma_0, \dots, \sigma_n) \) a \( G \)-derivation.
	In this case, we call \( \sigma_0 \) the \emph{initial string} and \( \sigma_n \) the \emph{final string}.
	Let \( Y = \qty{(w, v) \mid v \text{ is a derivation code with initial string } S \text{ and final string } w} \).
	\( Y \) is computable since we can produce a register machine that tests if a given derivation code can be produced from a fixed given grammar.
	But \( w \in \mathcal L(G) \iff \exists v,\, (w, v) \in Y \).
	This is \( \Sigma_1 \), as required.
\end{proof}
\begin{remark}
	The converse also holds; every computably enumerable set \( X \subseteq \mathbb W \) is a type 0 language.
	This will not be proven rigorously in this course; a sketch will be provided later.
\end{remark}

\subsection{Closure properties}
\begin{proposition}
	The computable sets are closed under intersection, union, complement, difference, and concatenation.
\end{proposition}
\begin{proof}
	Let \( A, B \) be computable sets, so \( \chi_A, \chi_B \) are computable functions.
	We obtain
	\[ \chi_{A \cap B}(\vb w) = \begin{cases}
		a & \chi_A(\vb w) = a \text{ and } \chi_B(\vb w) = a \\
		\varepsilon & \text{otherwise}
	\end{cases} \]
	For complement,
	\[ \chi_{\mathbb W \setminus A}(\vb w) = \begin{cases}
		a & \chi_A(\vb w) = \varepsilon \\
		\varepsilon & \text{otherwise}
	\end{cases} \]
	For concatenation, we suppose \( A, B \subseteq \mathbb W \) are one-dimensional.
	Given a word \( w \), we can iterate over all possible decompositions \( w = vu \) and check if \( v \in A, u \in B \).
	There are \( (\abs{w} + 1) \)-many such decompositions, so this minimisation will always halt.
\end{proof}
\begin{remark}
	The result for intersection is analogous to the product construction from deterministic automata; two computable functions can be evaluated in parallel since they always terminate, and then their results may be combined.
\end{remark}
\begin{proposition}
	The computably enumerable sets are closed under intersection, union, and concatenation.
	They are not closed under complement or difference.
\end{proposition}
\begin{proof}
	We have already shown that the complement of the halting problem \( \mathbb K \) is \( \Pi_1 \) but not \( \Sigma_1 \), so the computably enumerable sets are not closed under complement or difference.
	For intersection, the same construction as before works.
	\[ \chi_{A \cap B}(\vb w) = \begin{cases}
		a & \psi_A(\vb w) = a \text{ and } \psi_B(\vb w) = a \\
		\uparrow & \text{otherwise}
	\end{cases} \]
	This is because if \( \psi_A \) or \( \psi_B \) diverge, the result is \( \uparrow \) as desired.
	For union, we cannot compute \( \psi_A \) and \( \psi_B \) serially, since if \( \psi_A \uparrow \) we never run \( \psi_B \) at all.
	Using the zigzag technique, we can check \( \psi_A(\vb w) \) and \( \psi_B(\vb w) \) in parallel, halting if either halts at any time index.
	This idea is elaborated on an example sheet.

	For concatenation, consider the set \( Z \) of triples \( (w, v, u) \) such that \( v \) is an initial segment of \( w \), and after \( \#u \) steps, \( \psi_A(v) = a \) and \( \psi_B(v') = a \), where \( w = vv' \).
	Now define \( Y = \qty{(w, u), (w, u_{(0)}, u_{(1)} \in Z} \), so \( w \in AB \) if and only if there exists \( v \) such that \( (w, v) \in Y \).
\end{proof}
\begin{proposition}
	\( X \) is computably enumerable if and only if there is a partial computable function \( f \) such that \( X = \Im f \).
\end{proposition}
\begin{remark}
	In fact, a stronger result is true: \( X \) is computably enumerable if and only if there is a \emph{total} computable function \( f \) such that \( X = \Im f \).
	This is seen on an example sheet.
	This result justifies the name `computably enumerable'.
\end{remark}
\begin{proof}
	If \( \psi_X \) is computable, then so is
	\[ f(w) \begin{cases}
		w & \psi_X(w) \downarrow \\
		\uparrow & \text{otherwise}
	\end{cases} \]
	Clearly \( \Im f = X \) as required.

	Conversely, suppose \( f \colon \mathbb W \rightharpoonup \mathbb W \) with \( X = \Im f \).
	Suppose \( f = f_{c,1} \).
	We use the zigzag technique.
	Define the set \( Z \) of tuples \( (w, v, u) \) such that \( t_{c,1}(v,u) = a \) and \( f_{c,1}(v) = w \).
	Let \( Y = \qty{(w,v) \mid (w, v_{(0)}, v_{(1)}) \in Z} \), so \( \Im f = p(Y) \).
\end{proof}

\subsection{The Church--Turing thesis}
Register machines and recursive functions can both be used to define computability.
Historically, \emph{Turing machines} were also used to define and analyse computability.
% TODO: Copy from notes
There is another alternative, known as \emph{while programs}.
Notably, in this model, there is no special `halt state'; the program halts simply when there are no more instructions to execute.
Therefore the computation sequence in this model may be finite.
This gives rise to a notion of while computable functions, the functions computed by a while progarm.

\begin{theorem}
	Let \( f \colon \mathbb W^k \rightharpoonup \mathbb W \).
	Then, the following are equivalent.
	\begin{enumerate}
		\item \( f \) is (register machine) computable.
		\item \( f \) is partial recursive.
		\item \( f \) is Turing computable.
		\item \( f \) is while computable.
	\end{enumerate}
\end{theorem}
Turing machines, register machines, recursive functions, and while programs are superficially completely different approaches, yet the classes of computable functions that they define are exactly identical.
The \emph{Church--Turing thesis} is that this is universal; any reasonable notion of computation is equivalent.
Unfortunately, this is a nonmathematical statement, and cannot be made precise; this is simply a statement that describes our intuition about what computation means.
Accepting this thesis allows us to freely choose which notion of computability we would like to use for a given task.

The following is a proof sketch of the fact that computably enumerable sets are type 0 languages.
The sketch makes use of the fact that Turing computability is exactly register machine computability.
For more detail, see
% TODO: reference, Formal Languages, Salemaa?
\begin{proof}[Proof sketch]
	Let \( M \) be a Turing machine computing \( \psi_X \).
	Without loss of generality, let the read-write head be then moved to the front, so \( q_s \square w \square \xrightarrow M q_H \square a \square \).
	This is a rewrite system with the rules described by the definition of the Turing machine, transforming \( q_S \square w \square \) into \( q_H \square a \square \)

	We define a grammar which starts from \( S \), with \( S \to q_H \square a \square \), and performs all Turing instructions backwards.
	When \( q_S \) is seen, it deletes everything except \( w \).
\end{proof}

\subsection{Negative answers to decision problems}
We can use the Church--Turing thesis to give precise statements of our decision problems, without relying on an informal notion of `algorithm'.
First, we encode grammars in such a way that for all \( w \in \mathbb W \), there exists a grammar \( G \) such that \( \code(G) = w \); we write \( G_w \) for the associated grammar for a word.
Now,
\begin{enumerate}
	\item the word problem is \( \qty{(w, v) \mid w \in \mathcal L(G_v)} \);
	\item the emptiness problem is \( \qty{w \mid \mathcal L(G_w) = \varnothing} \);
	\item the equivalence problem is \( \qty{(w, v) \mid \mathcal L(G_w) = \mathcal L(G_v)} \).
\end{enumerate}
These are sets of tuples of words, so we can use our notion of computability.
We can now concretely define that such a problem is \emph{solvable} if the set is computable.
% TODO: Convert earlier uses of `decidable' to solvable
\begin{theorem}
	The word problem for type 0 grammars is unsolvable.
\end{theorem}
\begin{proof}
	Let \( W = \qty{(w, v) \mid w \in \mathcal L(G_v)} \).
	We want to show that \( W \) is not computable.
	Recall that \( \mathbb K_0 = \); we will use a proof analogous to the one used for this set.
	% TODO: Fill this in
	Suppose \( W \) is computable, so let
	\[ f(w) = \begin{cases}
		\uparrow & w \in \mathcal L(G_w) \\
		a & w \not\in \mathcal L(G_w)
	\end{cases} \]
	Then \( f \) is a computable function.
	Hence, \( \dom f \) is computably enumerable.
	So there exists a grammar \( G \) such that \( \mathcal L(G) = \dom f \).
	Let \( d \in \mathbb W \) be such that \( G = G_d \).
	Then
	\[ d \in \mathcal L(G_d) \iff d \in \dom f \iff d \not\in \mathcal L(G_d) \]
\end{proof}
